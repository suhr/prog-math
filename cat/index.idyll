[meta title:"Теория категорий" /]

[Header
  fullWidth:true
  title:"Теория категорий"
/]

Теория категорий была создана как скромный инструмент для нужд алгебраической топологии. Теперь же
она захватила всю математику, успешно завоёвывает информатику и совершает регулярные набеги на
естественные науки.

Причина столь впечатляющей мощи проста и описывается одним словом: *абстракция*. Так же, как в
программировании мы описываем интерфейсы с помощью методов, в теории категорий мы описываем
алгебраические структуры с помощью функций. При этом, внутренняя стуктура объектов, между которыми
заданы функции, скрыта от нас.

[Aside]Кроме, пожалуй, C, Go и PHP.[/Aside]
Мы, программисты, находимся в довольно привелегированном положении. Категорные понятия *уже*
даны нам в языках, подходах и культуре, хотя и не осознаются. И несмотря на многочисленные шутки
про непостижимость монад™, `flat_map` уже есть в каждом языке.

## Алгебраические структуры

Перед тем, как погружаться в категории, рассмотрим базовые алгебраические структуры.

### Функции

Но сначала вспомним функции над множествами. Как мы знаем, функция [Equation]f: A \to B[/Equation] это
сущность, которая сопоставляет каждому элементу множества [Equation]A[/Equation] некий единственный
элемент множества [Equation]B[/Equation]. Равенство двух функций определяется равенством их областей,
кообластей и графиков.

[Aside]
В математике обычно пишут композицию справо налево, как [Equation]g \circ f[/Equation]. Но мы читаем,
пишем и рисуем диаграммы слева направо, и потому так записывать композицию не будем.
[/Aside]
Композиция функций [Equation]f: A \to B[/Equation] и [Equation]g: B \to C[/Equation] определяется
следующим образом:

[Equation display:true]
(f \mathbin\bm; g)(x) = g(f(x))
[/Equation]

Для любого множества [Equation]A[/Equation] существует единичное отображение из [Equation]A[/Equation] в [Equation]A[/Equation]:

[Equation display:true]
\mathrm{id}_A(x) = x 
[/Equation]

Для него верно следующее:

[Equation display:true]
\mathrm{id}_A \mathbin\bm; f = f \mathbin\bm; \mathrm{id}_B = f
[/Equation]

Кроме того, композиция трёх функций ассоциативна (если определена):

[Equation display:true]
(f \mathbin\bm; g) \mathbin\bm; h = f \mathbin\bm; (g \mathbin\bm; h)
[/Equation]

Ассоциативность позволяет нарисовать диаграмму для композиции функций:

[div style:`{ "width": "80%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMSwwLCJCIl0sWzAsMCwiQSJdLFsyLDAsIkMiXSxbMywwLCJEIl0sWzEsMCwiZiJdLFswLDIsImciXSxbMiwzLCJoIl1d&embed"
height:150 width:500
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Но мы можем использовать диаграммы не только чтобы выразить существование функции между двумя множествами.
Равенства функций тоже можно выразить как диаграмму. Например, [Equation]f \mathbin\bm; \mathrm{id}_B = f[/Equation] можно нарисовать так:

[div style:`{ "width": "70%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMCwxLCJBIl0sWzIsMSwiQiJdLFsyLDAsIkIiXSxbMCwxLCJmIiwyXSxbMCwyLCJmIl0sWzIsMSwiXFxtYXRocm17aWR9X0IiXV0=&embed"
height:300 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Диаграмма, в которой равны все функции, соответствующие направленным путям между любыми двумя заданными вершинами,
называется коммутативной. Также говорят, что диаграмма коммутирует.

Функция [Equation]f^{-1}[/Equation] называется обратной к [Equation]f: A \to B[/Equation],
если [Equation]f \mathbin\bm; f^{-1} = \mathrm{id}_A[/Equation] и [Equation]f^{-1} \mathbin\bm; f = \mathrm{id}_B[/Equation].
Как мы знаем, функция имеет обратную тогда и только тогда, когда она биективна.

Но для инъективных и сюръективных функцих есть более слабый вариант понятия обратной функции. Пусть
следующая диаграмма коммутирует:

[div style:`{ "width": "65%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMiwwLCJBIl0sWzEsMCwiQiJdLFswLDAsIkEiXSxbMSwwLCJnIl0sWzIsMSwiZiJdLFsyLDAsIlxcbWF0aHJte2lkfV9BIiwyLHsiY3VydmUiOjJ9XV0=&embed"
height:150 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Тогда функция [Equation]f[/Equation] называется левой обратной к функции [Equation]g[/Equation], а
функция [Equation]g[/Equation] называется правой обратной к функции [Equation]f[/Equation].

**Утверждение:** в этом случае [Equation]f[/Equation] инъективна, а [Equation]g[/Equation] — сюръективна.

Действительно, пусть [Equation]a \in A[/Equation]. Тогда имеем:

[Equation display:true]
a \xmapsto{f} b \xmapsto{g} a
[/Equation]

Так как [Equation]a[/Equation] произвольно, [Equation]g[/Equation] должна быть сюръекцией. Так
как [Equation]b[/Equation] соответствует единственное [Equation]a[/Equation], то [Equation]f[/Equation] инъективна.

Пусть [Equation]\bm 0 = \varnothing[/Equation], а [Equation]\bm 1 = \{\varnothing\}[/Equation].
Каждому множеству [Equation]A[/Equation] соответствует функция из [Equation]\bm 0[/Equation] в [Equation]A[/Equation],
и единственная функция из [Equation]A[/Equation] в [Equation]\bm 1[/Equation]. Каждому же [Equation]x \in A[/Equation]
соответствует единственная функция [Equation]\underline{x}: \bm 1 \to A[/Equation].

Это позволяет выразить применение функции как композицию:

[Equation display:true]
\underline 2 \mathbin\bm; sq = \underline 4 \qquad sq(x) = x^2
[/Equation]

Каждой функции [Equation]f: A \times B \to C[/Equation] соответствуют единственная функция
[Equation]g: A \to (B \to C)[/Equation]:

[Equation display:true]
g(x) = y \mapsto f(x, y)
[/Equation]

Мы будем писать [Equation]f(x, \_)[/Equation] имея в виду [Equation]y \mapsto f(x, y)[/Equation].
При этом [Equation]f(\_, \_)[/Equation] это то же, что и [Equation](x, y) \mapsto f(x, y)[/Equation].

### Отношение порядка

Отношение [Equation](\leqslant) : S \times S \to \bm 2[/Equation] называется отношением предпорядка,
если оно удволетворяет следующим аксиомам:

- Рефлексивность: [Equation](\forall x \in S)\enspace s \leqslant s[/Equation]
- Транзитивность: [Equation](\forall x, y, z \in S)\enspace x \leqslant y \mathbin\mathrm{and} y \leqslant z \implies x \leqslant z[/Equation]

Отношение предпорядка называется отношением порядка, если дополнительно выполняется

- [Equation](\forall x, y \in S)\enspace x \leqslant y \mathbin\mathrm{and} y \leqslant x \implies x = y[/Equation] (антисимметричность)

Отношение порядка называется линейным, если к тому же [Equation](\forall x, y \in S)\enspace x \leqslant y \mathbin\mathrm{or} y \leqslant x[/Equation] (иначе говоря, любые два элемента сравнимы).

Примеры отношения предпорядка:

- Существование пути в направленном графе между двумя узлами

Примеры отношения порядка:

- Обычное отношение порядка на числах
- Отношение подмножества
- Мощность множеств

Упорядоченное множество это множество с заданым на нём отношением порядка. Формально это пара [Equation](S, \leqslant)[/Equation].
Для этой пары определим проекции:

[Equation display:true]
\begin{aligned}
set((S, \_)) &= S \\
rel((\_, \leqslant)) &= (\leqslant)
\end{aligned}
[/Equation]

Мы будем писать [Equation]x \in S_{\leqslant}[/Equation] имея в виду [Equation]x \in set(S_{\leqslant})[/Equation].

Если посмотреть внимательнее на аксиомы отношения предпорядка, можно заметить сходство со свойствами
композиции. Сходство не случайное: отношение порядка можно представить как множество функций.

Конкретнее, определим множество

[Equation display:true]
\mathrm{arr}(x, y) = \{f : \{x\} \to \{y\} \mid x \leqslant y \}
[/Equation]

Посмотрим на элементы [Equation]\mathrm{arr}(x, x)[/Equation] как на абстракные стрелки из [Equation]x[/Equation] в [Equation]y[/Equation]:

[Equation display:true]
\begin{aligned}
\exists id_x &\in \mathrm{arr}(x, x) \qquad (\forall x \in S) \\
\exists f_{xy} \mathbin\bm; f_{yz} &\in \mathrm{arr}(x, z) \qquad (\forall f_{xy} \in \mathrm{arr}(x, y), f_{yz} \in \mathrm{arr}(y, z))
\end{aligned}
[/Equation]

Тождественная стрелка соответствует рефлексивности, когда же композиция соответствует транзитивности.

[Aside]Такие диаграммы называются диаграммами Хассе, и их рисуют так, чтобы все стрелки были направленны вверх.
При этом наконечник стрелки зачастую опускают.[/Aside]
Как и для функций, для стрелок можно рисовать диаграммы. Например, вот диаграмма для [Equation](\mathcal{P}(\{a, b, c\}), \subseteq)[/Equation]:

[div style:`{ "width": "60%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsOCxbMSwzLCJcXHtcXH0iXSxbMCwyLCJcXHthXFx9Il0sWzEsMiwiXFx7YlxcfSJdLFsyLDIsIlxce2NcXH0iXSxbMCwxLCJcXHthLGJcXH0iXSxbMSwxLCJcXHthLCBjXFx9Il0sWzIsMSwiXFx7YiwgY1xcfSJdLFsxLDAsIlxce2EsIGIsY1xcfSJdLFswLDFdLFswLDJdLFswLDNdLFsxLDRdLFsxLDVdLFsyLDRdLFsyLDZdLFszLDZdLFszLDVdLFs0LDddLFs1LDddLFs2LDddXQ==&embed"
height:400 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Пусть [Equation]S_\leqslant[/Equation] и [Equation]T_\sqsubseteq[/Equation] — упорядоченные множества.
Функция [Equation]f : S \to T[/Equation] называется монотонной, если

[Equation display:true]
(\forall x, y \in S)\enspace x \leqslant y \implies f(x) \sqsubseteq f(y)
[/Equation]

Отображения, сохраняющие структуру, в алгебре обычно называются гомоморфизмами. В случае множеств,
в определение функции входят множества, соответствующие области и кообласти функции. В случае же упорядоченных
множеств нам бы хотелось, чтобы область и кооблась были также упорядоченными множествами. Поэтому мы
определяем гомоморфизм из [Equation]S_\leqslant[/Equation] в [Equation]T_\sqsubseteq[/Equation] как
тройку [Equation](S_\leqslant, T_\sqsubseteq, f)[/Equation].

Кроме того, для этой тройки определим проекции

[Equation display:true]
\begin{aligned}
dom((S_\leqslant, \_, \_)) &= S_\leqslant \\
cod((\_, T_\sqsubseteq, \_)) &= T_\sqsubseteq \\
set((\_, \_, f)) &= f
\end{aligned}
[/Equation]

Аналогично отношению принадлежности, если [Equation]f : S_\leqslant \to T_\sqsubseteq[/Equation], то
[Equation]f(x)[/Equation] означает [Equation]set(f)(x)[/Equation].

[Aside]
Из того, что [Equation]set(f)[/Equation] — биекция, вовсе не следует, что [Equation]f[/Equation] — изоморфизм.
Например, гомоморфизм из [Equation]Free(\{\varnothing, \{\varnothing\}\})[/Equation] в [Equation](\mathcal{P}(\{\varnothing\}), \subseteq)[/Equation] не является
изоморфизмом, так как обратная функция не является монотонной.
[/Aside]
Гомоморфизм [Equation]f : S_\leqslant \to T_\sqsubseteq[/Equation] называется изоморфизмом, если
существует такой гомоморфизм [Equation]f^{-1} : T_\sqsubseteq \to S_\leqslant[/Equation], что
[Equation]f \mathbin\bm; f^{-1} = \mathrm{id}_{S_\leqslant}[/Equation] и [Equation]f^{-1} \mathbin\bm; f = \mathrm{id}_{T_\sqsubseteq}[/Equation].
Соответствующие упорядоченные множества называются изоморфными (пишется [Equation]S_\leqslant \cong T_\sqsubseteq[/Equation]).

Любое множество можно превратить в упорядоченное с помощью дискретного (свободного) отношения порядка:

[Equation display:true]
Free(S) = (S, (x, y) \mapsto x = y)
[/Equation]

В частности, мы можем определить [Equation]\bm 0[/Equation] и [Equation]\bm 1[/Equation]:

[Equation display:true]
\begin{aligned}
\bm 0 &= Free(\{\}) \\
\bm 1 &= Free(\{\varnothing\})
\end{aligned}
[/Equation]

И как и в случае с обычными множествами, для любого упорядоченного множества [Equation]S[/Equation] существует
единственный гомоморфизм из [Equation]\bm 0[/Equation] в [Equation]S[/Equation], и единственный гомоморфизм из [Equation]S[/Equation] в [Equation]\bm 1[/Equation].

**Предложение:** пусть [Equation]S[/Equation] — множество, [Equation]P[/Equation] — упорядоченное множество,
а [Equation]f : S \to set(P)[/Equation]. Тогда существует единственный гомоморфизм [Equation]u : Free(S) \to P[/Equation],
такой, что следующая диаграмма коммутирует:

[div style:`{ "width": "70%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMCwwLCJTIl0sWzIsMCwic2V0KEZyZWUoUykpIl0sWzIsMiwic2V0KFApIl0sWzEsMiwic2V0KHUpIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMSwiaWRfUyJdLFswLDIsImYiLDJdXQ==&embed"
height:300 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Действительно, [Equation]u = (Free(S), P, f)[/Equation].

Таким образом, [Equation]Free(S)[/Equation] является наиболее общим упорядоченным множеством, порождённым
множеством [Equation]S[/Equation].

Свободные объекты бывают и у других алгебраических структур, но,
как правило, определяются куда менее прямолинейно, хотя и удволетворяют тому же универсальному
свойству, только лишь [Equation]id_S[/Equation] заменяется на некое каноническое вложение [Equation]i : S \to Free(S)[/Equation].

Пусть [Equation]S[/Equation] и [Equation]T[/Equation] — упорядоченные множества. Прямое произведение [Equation]S \times T[/Equation] это
следующее упорядоченное множество:

[Equation display:true]
\begin{aligned}
S \times T = (
&set(S) \times set(T), \\
&((a, x), (b, y)) \mapsto rel(S)(a, b) \mathbin\mathrm{and} rel(T)(x, y))
\end{aligned}
[/Equation]

Как и у свободного упорядоченного множества, у прямого произведения есть универсальное свойство.

**Предложение:** пусть [Equation]S[/Equation] и [Equation]T[/Equation] — упорядоченные множества.
Пусть также даны гомоморфизмы [Equation]f : X \to S[/Equation] и [Equation]g : X \to T[/Equation].
Тогда существует единственный гомоморфизм [Equation]u : X \to S \times T[/Equation], такой, что
следующаяя диаграмма коммутирует:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywwLCJYIl0sWzMsMiwiU1xcdGltZXMgVCJdLFswLDMsIlMiXSxbNiwzLCJUIl0sWzAsMSwidSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMywiZyJdLFswLDIsImYiLDJdXQ==&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Здесь [Equation]\pi_1[/Equation] и [Equation]\pi_2[/Equation] это проекции из [Equation]S \times T[/Equation]:

[Equation display:true]
\begin{aligned}
\pi_1((x, \_)) &= x \\
\pi_2((\_, y)) &= y
\end{aligned}
[/Equation]

В самом деле, единственным таким гомоморфизмом является следующий:

[Equation display:true]
\begin{aligned}
u = (&X, \\
&S \times T, \\
&x \mapsto (f(x), g(x)))
\end{aligned}
[/Equation]

Как и произведение множеств, прямое произведение удволетворяет следующим свойствам:

[Equation display:true]
\begin{aligned}
S \times \bm 0 &\cong \bm 0 \\
S \times \bm 1 &\cong \bm S \\
S \times T &\cong T \times S \\
(S \times T) \times R &\cong S \times (T \times R)
\end{aligned}
[/Equation]

Пусть [Equation]S[/Equation] — упорядоченное множество. Элемент [Equation]a \in S[/Equation] называется минимальным,
если не существует такого [Equation]b \in S[/Equation], что [Equation]a > b[/Equation] ([Equation]a[/Equation] и [Equation]b[/Equation] могут быть несравнимы).
Элемент [Equation]a \in S[/Equation] называется наименьшим, если [Equation](\forall b \in S)\enspace a \leqslant b[/Equation].

Аналогично определяются максимальный и наименьший элементы. Наибольший и наименьший элементы обозначаются,
соответственно, как [Equation]\operatorname{max} S[/Equation] и [Equation]\operatorname{min} S [/Equation].

Кроме того, для [Equation]x, y \in S[/Equation] можно определить операции пересечения и объединения:

[Equation display:true]
\begin{aligned}
x \wedge y &= \operatorname{max}\ \{s \in S \mid s \leqslant x \mathbin\mathrm{and} s \leqslant y\} \\
x \vee y &= \operatorname{min}\ \{s \in S \mid x \leqslant s \mathbin\mathrm{and} y \leqslant s\} \\
\end{aligned}
[/Equation]

В случае, когда [Equation]x[/Equation] и [Equation]y[/Equation] сравнимы, [Equation]x \wedge y = \operatorname{min}\ \{x, y\}[/Equation], а [Equation]x \vee y = \operatorname{max}\ \{x, y\}[/Equation].

[Aside]Слова «единственная» и «коммутирует» в данном контексте могут показаться избыточными, но в случае элементов упорядоченного множества они и в самом деле избыточны.[/Aside]
Если мы выразим выражение для пересечения элементов как диаграмму стрелок, то обнаружим, что пересечение
также обладает универсальным свойством. А именно, пусть [Equation]s \leqslant x[/Equation] и [Equation]s \leqslant y[/Equation].
Тогда существует единственная стрелка [Equation]s \leqslant x \wedge y[/Equation], такая, что следующая
диаграмма коммутирует:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywxLCJ4IFxcd2VkZ2UgeSJdLFszLDMsInMiXSxbMCwwLCJ4Il0sWzYsMCwieSJdLFsxLDAsIiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDNdLFswLDJdLFsxLDJdLFsxLDNdXQ==&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Обращение всех стрелок даёт универсальное свойство для объединения элементов.

Линейно упорядоченное множество называется вполне упорядоченным, если любое непустое его подмножество
содержит наименьший элемент этого подмножества. Соответствующее отношение порядка называется фундированным.

Вполне упорядоченные множества тесно связаны с рекурсией и математической индукцией. Чтобы это показать,
введём один важный математический принцип.

[Aside]Вообще, это утверждение является теоремой, которая в теории множеств доказывается достаточно
извращённым образом. Мы её доказывать не будем, тем более, что в некоторых аксиоматиках теории множеств
это утверждение является аксиомой (например, в ETCS).[/Aside]
**Принцип итерации:** пусть [Equation]f : A \to A[/Equation]. Тогда, для любого [Equation]a \in A[/Equation] существует
функция [Equation]g : \Bbb N \to A[/Equation], такая, что [Equation]g(0) = a[/Equation] и [Equation]g(n + 1) = f(g(n))[/Equation].

Иначе говоря, [Equation]f^{n}(a)[/Equation] существует и является функцией от [Equation]n[/Equation].

Для элемента [Equation]a[/Equation] можно определить элемент, следующий за ним:

[Equation display:true]succ(a) = \operatorname{min}\ \{s \mid s > a \}[/Equation]

Элемент вполне упорядоченного множества называется предельным, если он не следует ни за каким элементом.

**Предложение:** пусть [Equation]S[/Equation] — линейно упорядоченное множеств, в котором не существует бесконечной
цепи вида [Equation]\dots < a_1 < a_0[/Equation]. Тогда [Equation]S[/Equation] является вполне упорядоченным множеством.

От противного. Пусть [Equation]S[/Equation] не является вполне упорядоченным. Это означает, что
существует непустое множество [Equation]A \subseteq S[/Equation], не имеющее наименьшего элемента.

Введём функцию:

[Equation display:true]
p(x) = \varepsilon(\{a \in A \mid a < x\})
[/Equation]

Эта функция определена на всех элементах множества [Equation]A[/Equation]: в самом деле, если
множество [Equation]\{a \in A \mid a < m\}[/Equation] пусто для какого-то [Equation]m \in A[/Equation],
то [Equation]m[/Equation] является наименьшим элементом множества [Equation]A[/Equation].

Но в таком случае [Equation]p^n(\varepsilon(A))[/Equation] определяет бесконечную нисходящую цепь,
что противоречит тому, что подобной цепи не существует.

Из доказанного следует, что любой элемент вполне упорядоченного множества представим
в виде [Equation]succ^n(\lambda)[/Equation], где [Equation]n \in \Bbb N[/Equation], а [Equation]\lambda[/Equation] — некий
предельный элемент.

Принцип математической индукции можно обобщить на произвольные вполне упорядоченные множества.

[Aside]Формально, первый пункт избыточен, так как наименьший элемент вполне упорядоченного множества является
и предельным элементом. Однако, с ним теорема выглядит *естественнее*.[/Aside]
**Предложение (трансфинитная индукция):** пусть [Equation]S[/Equation] — вполне упорядоченное множество,
а [Equation]\varphi : set(S) \to \bm 2[/Equation]. Кроме того, пусть верно следующее:

1. [Equation]\varphi(\operatorname{min} A)[/Equation]
2. [Equation](\forall s \in S)\enspace \varphi(s) \implies \varphi(succ(s))[/Equation]
3. [Equation]((\forall s < \lambda)\enspace \varphi(s)) \implies \varphi(\lambda)[/Equation] для всех предельных [Equation]\lambda \in S[/Equation]

Тогда [Equation]\varphi(s)[/Equation] истино для всех [Equation]s \in S[/Equation].

Пусть это не так, тогда множество [Equation]C = \{s \in S \mid \operatorname{not} \varphi(s)\}[/Equation] непусто.
Так как [Equation]S[/Equation] это вполне упорядоченное множество, то существует [Equation]c = \operatorname{min} C[/Equation].

Однако:

1. [Equation]c \ne \operatorname{min} A[/Equation]
2. [Equation](\forall s \in S)\enspace c \ne succ(s)[/Equation], потому что иначе [Equation]c \ne \operatorname{min} C[/Equation]
3. [Equation]c[/Equation] не является предельным элементом, потому что иначе опять [Equation]c \ne \operatorname{min} C[/Equation]

Мы исчерпали все возможные [Equation]c[/Equation]. Следовательно, такого элемента не существует, и [Equation]\varphi(s)[/Equation] истино для всех [Equation]s \in S[/Equation].

Индукция это схема *доказательства* для вполне упорядоченных множеств. Кроме этого, нам нужна схема построения
функция из элементов вполне упорядоченного множества.

**Предложение (трансфинитная рекурсия):** для вполне упорядоченного множества [Equation]S[/Equation],
существует единственная функция [Equation]f : set(S) \to Z[/Equation], такая, что

[Equation display:true]f(s) = g(s)(f|_{< s})[/Equation]

Здесь [Equation]g : (s \in S) \to (S_{<s} \to B) \to B[/Equation] , где [Equation]S_{<s} = \{x \in S \mid x < s\}[/Equation],
а [Equation]f|_{< s}[/Equation] это ограничение функции [Equation]f[/Equation]:

[Equation display:true]
f|_{< s} : S_{<s} \to B
\qquad
f|_{< s}(x) = f(x)
[/Equation]

Чтобы построить такую функцию, определим множество

[Equation display:true]
U = \left\{(s, f) \ \Bigg|\ 
\begin{aligned}
  s \in S \ &\mathrm{and}\ f : S_{<s} \cup \{s\} \to Z \\
  &\mathrm{and}\ f(s) = g(s)(f|_{< s})
\end{aligned}\right\}
[/Equation]

Докажем индуктивно, что [Equation](\forall s \in S)\ (\exists f)\enspace (s, f) \in U[/Equation].

[ol]
[li]Если [Equation]s = \operatorname{min} S[/Equation], то [Equation]f|_{< s} : \bm 0 \to B[/Equation],
и выражение [Equation]g(s)(f|_{< s})[/Equation] определено однозначно[/li]
[li]Если [Equation](s, f) \in U[/Equation], то [Equation](succ(s), f_+) \in U[/Equation], где
[Equation display:true]
f_+(x) = \begin{cases}
f(x) &x < s \\
g(s)(f) &x = s
\end{cases}
[/Equation][/li]
[li]Пусть [Equation](\forall s < \lambda)\ (\exists f_s)\enspace (s, f_s) \in U[/Equation].
Определим функцию [Equation]f_{<\lambda} : S_{<\lambda} \to Z[/Equation] следующим образом:

[Equation display:true]
f_{<\lambda}(s) = f_s(s) \qquad (s, f_s) \in U
[/Equation]

Тогда [Equation](\lambda, f_\lambda) \in U[/Equation], где
[Equation display:true]
f_\lambda(s) = \begin{cases}
f_{<\lambda}(s) &s < \lambda  \\
g(s)(f_{<\lambda}) &s = \lambda
\end{cases}
[/Equation][/li]
[/ol]

Доказав, что множество [Equation]U[/Equation] содержит все частично определённые функции,
мы можем определить искомую функцию [Equation]f[/Equation] как

[Equation display:true]
f(s) = f_s(s) \qquad (s, f_s) \in U
[/Equation]

### Индуктивные типы

В программировании у нас есть такая замечательная вещь, как алгебраические типы данных. В математике
же так не принято, однако многие вещи проще и естественнее выражать рекурсивно, так что имеет смысл
ввести аналог алгебраических типов в математике.

Для начала, нам потребуются типы-суммы. Их аналогом в математике является размеченное объединение:

[Aside]
Чаще его обозначают как [Equation]A \sqcup B[/Equation]. Но мы пишем [Equation]+[/Equation]
чтобы подчеркнуть связь с [Equation]\times[/Equation].
[/Aside]
[Equation display:true]
S_1 + \dots + S_n = \hspace{-0.7em}\bigcup_{i \in \{0, \dots, n\}} \hspace{-0.7em}(\{i\} \times A)
[/Equation]

Размеченными объединениями неудобно пользоваться без имён, так что стоит заимстововать искусство
давать вещам имена из программирования.

Запись [Equation]S = (left: A) + (right: B)[/Equation] означает, что [Equation]S = A + B[/Equation]
и при этом определены следующие функции в [Equation]S[/Equation]:

[Equation display:true]
\begin{aligned}
left(a) &= (0, a) \\
right(b) &= (1, b)
\end{aligned}
[/Equation]

Аналогично, запись [Equation]S = (first: A) \times (second: B)[/Equation] означает,
что [Equation]S = A \times B[/Equation] и при этом определены следующие функции из [Equation]S[/Equation]:

[Equation display:true]
\begin{aligned}
first((x, y)) &= x \\
second((x, y)) &= y
\end{aligned}
[/Equation]

Элемент сооветствующего множества мы будем обозначать или как [Equation](first = a, second = b)[/Equation],
или просто как [Equation](a, b)[/Equation].

Как и произведения, размеченные объединения обладают универсальным свойством.

**Предложение:** пусть [Equation]f : A \to Z[/Equation] и [Equation]g : B \to Z[/Equation]. Тогда существует
единственная стрелка [Equation]u : (i_1: A) + (i_2: B) \to Z[/Equation], такая, что следующая диаграмма коммутирует:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywxLCJBK0IiXSxbMywzLCJaIl0sWzAsMCwiQSJdLFs2LDAsIkIiXSxbMiwwLCJpXzEiXSxbMywwLCJpXzIiLDJdLFsyLDEsImYiLDJdLFszLDEsImciXSxbMCwxLCJ1IiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Действительно, единственной такой функция является следующая:

[Equation display:true]
u(s) = \begin{cases}
f(a) &s = (0, a) \\
g(b) &s = (1, b)
\end{cases}
[/Equation]

Мы не можем выразить рекурсивные суммы прямо, так как схема построения классов не допускает рекурсии.
Но мы можем построить их итеративно.

Например, рассмотрим выражение

[Equation display:true]T(A) = (leaf: A) + (node: T(A) \times T(A))[/Equation]

Сначала мы строим множество, содержащее только нерекурсивные части этого выражения:

[Equation display:true]
T_0(A) = \{0\} \times A
[/Equation]

Затем мы определяем функцию, подставляющую данное множество в формальное определение [Equation]T[/Equation]:

[Equation display:true]
\tau(A)(T) = (\{0\} \times A) \cup (\{1\} \times (T(A) \times T(A)))
[/Equation]

И определяем [Equation]T[/Equation] как:

[Equation display:true]
T(A) = \bigcup_{n \in \Bbb N} T_n(A) \qquad T_n(A) = \tau(A)^{n} (T_0(A))
[/Equation]

Уровень элемента [Equation]t \in T[/Equation] определим как

[Equation display:true]
lvl(t) = \min\,\{n \in \Bbb N \mid t \in T_n(\_)\}
[/Equation]

Уровень элемента позволяет определять рекурсивные функции на рекурсивно определённом множестве. Например,
пусть мы хотим определить функцию [Equation]sum: T(\Bbb Z) \to \Bbb Z[/Equation], складывающую все листья
дерева. Для этого мы сначала определяем функцию [Equation]s: (n \in \Bbb N) \to T_n(\Bbb Z) \to \Bbb Z[/Equation] следующим образом:

[Equation display:true]
s(n) = \begin{cases}
leaf(l) &\mapsto l \\
node(x, y) &\mapsto s(n - 1)(x) + s(n - 1)(y) 
\end{cases}
[/Equation]

И затем определяем искомую функцию как

[Equation display:true]
sum(t) = s(lvl(t))(t)
[/Equation]

### Моноиды

Моноид это тройка [Equation](set = M, mul = (\cdot), unit = e)[/Equation],
где [Equation]M[/Equation] — множество, [Equation](\cdot): M \times M \to M[/Equation], а [Equation]e \in M[/Equation].
При этом должны выполняться следующие аксиомы:

[Equation display:true]
\begin{aligned}
(\forall m \in M)\enspace &e \cdot m = m \cdot e = m \\
(\forall m, n, p \in M)\enspace (&m \cdot n) \cdot p = m \cdot (n \cdot p)
\end{aligned}
[/Equation]

Первая аксиома это аксиома единицы, когда же вторая — ассоциативность.

Примеры моноидов:

- Сложение и умножение чисел
- Конкатенация строк
- Объединение и пересечение множеств
- Умножение матриц n × n
- Композиция функций [Equation]S \to S[/Equation]
- И многое, многое другое

Как и для упорядоченных множеств, мы будем писать [Equation]m \in M[/Equation] имея в виду [Equation]m \in set(M)[/Equation].

Элемент [Equation]m^{-1} \in M[/Equation] называется обратным к [Equation]m[/Equation] если [Equation]m \cdot m^{-1} = m^{-1} \cdot m = e[/Equation].
Моноид, каждый элемент которого обратим, называется группой.

Аксиомы моноида не просто так похожи на свойства композиции функций: каждому [Equation]m \in M[/Equation]
можно сопоставить соответствующую функцию из [Equation]set(M)[/Equation] в [Equation]set(M)[/Equation]:

[Equation display:true]
f_m = \_ \cdot m
[/Equation]

Умножению элементов [Equation]m \cdot n[/Equation] соответствует композиция функций [Equation]f_m \mathbin{\bm;} f_n[/Equation].

Гомоморфизм из моноида [Equation]M^{(\cdot)}[/Equation] в моноид [Equation]N^{(*)}[/Equation] это
тройка [Equation](dom = M^{(\cdot)}, cod = N^{(*)}, set = f)[/Equation], где [Equation]f : M \to N[/Equation], для которой верно следующее:

[Equation display:true]
\begin{aligned}
f(unit(M^{(\cdot)})) &= unit(N^{(*)}) \\
f(x \cdot y) &= f(x) * f(y) \qquad (\forall x, y \in M)
\end{aligned}
[/Equation]

Как и для отношения принадлежности, мы пишем [Equation]f(m)[/Equation] имея в ввиду [Equation]set(f)(m)[/Equation].

Гомоморфизм переносит равенства из одного моноида в другой.
Например, в случае [Equation](\_ \bmod 12) : \Bbb Z^{+} \to \Bbb Z^{+}/12[/Equation]:

[Equation display:true]
6 + 13 - 16 = 3 \implies 6 +_{12} 1 +_{12} 8 = 3
[/Equation]

В отличие от упорядоченных множеств, биективный гомоморфизм моноидов обратим.

**Предложение:** пусть [Equation]f : M^{(\cdot)} \to N^{(*)}[/Equation] — гомоморфизм, такой, что [Equation]set(f)[/Equation] — биекция.
Тогда [Equation](N^{(*)}, M^{(\cdot)}, set(f)^{-1})[/Equation] также является гомоморфизмом.

В самом деле:

[Equation display:true]
\begin{aligned}
f^{-1}(unit(N^{(*)})) &= unit(M^{(\cdot)}) \\
f^{-1}(f(x \cdot y)) &= x \cdot y \\
&= f^{-1}(f(x) * f(y))
\end{aligned}
[/Equation]

Подставив [Equation]x = f^{-1}(\xi)[/Equation] и [Equation]y = f^{-1}(\eta)[/Equation] во второе
уравнение, получаем:

[Equation display:true]
f^{-1}(\xi * \eta) = f^{-1}(\xi) \cdot f^{-1}(\eta)
[/Equation]

Тривиальный моноид это моноид, содержащий только лишь нейтральный элемент:
[Equation display:true]\bm 1 = (\{e\}, {\cdot}, e)[/Equation]

Как и в случае со множествами, каждому моноиду [Equation]M[/Equation] соответствует единственный
гомоморфизм из [Equation]M[/Equation] в [Equation]\bm 1[/Equation]. Однако, гомоморфизм из [Equation]\bm 1[/Equation]
в [Equation]M[/Equation] также единственнен.

Прямое произведение моноидов [Equation]M^{(\cdot)}[/Equation] и [Equation]N^{(*)}[/Equation] это
моноид [Equation]M^{(\cdot)} \times N^{(*)}[/Equation], определённый следующим образом:

[Equation display:true]
\begin{aligned}
M^{(\cdot)} \times N^{(*)} = (
  &M \times N, \\
  &((a, x), (b, y)) \mapsto (a \cdot b, x * y), \\
  &(unit(M), unit(N))
)
\end{aligned}
[/Equation]

Для прямого произведения [Equation]M\times N[/Equation] определены проекции в [Equation]M[/Equation]
и [Equation]N[/Equation]:

[Equation display:true]
\begin{aligned}
\pi_1((a, x)) = a \\
\pi_2((a, x)) = x
\end{aligned}
[/Equation]

Для любых моноидов [Equation]M[/Equation], [Equation]N[/Equation] и [Equation]P[/Equation] верно:

[Equation display:true]
\begin{aligned}
M \times \bm 1 &\cong M \\
M \times N &\cong N \times M \\
(M \times N) \times P &\cong M \times (N \times P)
\end{aligned}
[/Equation]

Произведение моноидов обладает тем же универсальным свойством, что и произведение упорядоченных множеств:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywwLCJYIl0sWzMsMiwiTVxcdGltZXMgTiJdLFswLDMsIk0iXSxbNiwzLCJOIl0sWzAsMSwidSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMywiZyJdLFswLDIsImYiLDJdXQ==&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Действительно, есть лишь один способ построить такой гомоморфизм:
[Equation display:true]
u(x) = (f(x), g(x))
[/Equation]

Как и среди упорядоченных множеств, среди моноидов есть свободные. Однако, свободный моноид определяется
уже не столь тривиально.

Основная идея проста: если мы не знаем, что такое [Equation]x \cdot y[/Equation], так пусть *само
выражение* и будет элементом! Конкретно, пусть [Equation]S[/Equation] — множество. Определим
множество [Equation]F[/Equation] следующим образом:

[Equation display:true]
F = (e: \bm 1) + (val: S) + ((\cdot): F \times F)
[/Equation]

Это множество можно рассматривать как своего рода синтаксическое дерево, в листьях которого либо
нейтральный элемент, либо элементы множества [Equation]S[/Equation].

Чтобы превратить [Equation]F[/Equation] в моноид, определим отношение эквивалентности как наименьшее отношение,
соответствующее следующим условиям:

[Equation display:true]
\begin{aligned}
e \cdot x &\sim x \\
x \cdot e &\sim x \\
(x \cdot y) \cdot z &\sim x \cdot (y \cdot z) \\
\end{aligned}
\qquad
\begin{aligned}
x \sim y &\implies x \cdot z \sim y \cdot z \\
y \sim z &\implies x \cdot y \sim x \cdot z \\
\,
\end{aligned}
[/Equation]

Взяв фактор-множество, получаем свободный моноид:

[Equation display:true]
\begin{aligned}
Free(S) = (
  &F/{\sim},\\
  &([a]_\sim, [b]_\sim) \mapsto [a \cdot b]_\sim,\\
  &e
)
\end{aligned}
[/Equation]

Моноиды, изоморфные [Equation]Free(S)[/Equation], также называются называется свободными. Примеры:

- (`List[T]`, `concat`, `[]`)
- (`String`, `concat`, `""`)
- [Equation]\Bbb N^{+}[/Equation]

Но чтобы по праву называть [Equation]Free(S)[/Equation] свободным моноидом, нужно доказать, что
выполняется соответствующее универсальное свойство:

[div style:`{ "width": "70%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMCwwLCJTIl0sWzIsMCwic2V0KEZyZWUoUykpIl0sWzIsMiwic2V0KE0pIl0sWzEsMiwic2V0KHUpIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMSwiaSJdLFswLDIsImYiLDJdXQ==&embed"
height:300 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Здесь [Equation]i[/Equation] это естественное вложение [Equation]S[/Equation] в [Equation]set(Free(S))[/Equation]:

[Equation display:true]
i(s) = [val(s)]_\sim
[/Equation]

Гомоморфизм [Equation]u[/Equation] можно определить рекурсивно:

[Equation display:true]
u = \begin{cases}
e &\mapsto unit(M) \\
val(s) &\mapsto f(s) \\
x \cdot y &\mapsto mul(M)(u(x), u(y))
\end{cases}
[/Equation]

Из этого определения следует, что [Equation]u[/Equation] в самом деле единственнен: второе равенство следует из
коммутативности диаграммы, когда же остальные — из определения гомоморфизма.

Добавляя к отношению эквивалентности свободного моноида дополнительные условия, мы можем получать
другие моноиды. Например, пусть [Equation]Z = \{s, p\}[/Equation] и пусть [Equation]\sim_Z[/Equation]
удволетворяет и условиям свободного моноида, и следующим условиям:

[Equation display:true]
\begin{aligned}
val(s) \cdot val(p) \sim_Z e \\
val(p) \cdot val(s) \sim_Z e
\end{aligned}
[/Equation]

Тогда соответствующий моноид [Equation]F/{\sim_Z}[/Equation] изоморфен моноиду целых чисел по сложению.
Соответствующий изоморфизм нетрудно определить:

[Equation display:true]
f = \begin{cases}
[e]_{\sim_Z} &\mapsto 0 \\
[\underbrace{val(s) \cdot val(s) \cdot \dots}_n]_{\sim_Z} &\mapsto n \\
[\underbrace{val(p) \cdot val(p) \cdot \dots}_n]_{\sim_Z} &\mapsto -n \\
\end{cases}
[/Equation]

Других классов эквивалентности [Equation]F/{\sim_Z}[/Equation] не содержит,
так как [Equation]s[/Equation] и [Equation]p[/Equation] взаимно уничтожают друг друга.

Подобное построение называется заданием моноида и записывается так:

[Equation display:true]\langle s, p \mid s \cdot p = p \cdot s = e \rangle[/Equation]

Кроме произведений и свободного моноида, мы можем определить аналог размеченного объединения для моноидов.
Пусть [Equation]M[/Equation] и [Equation]N[/Equation] — моноиды. Определим множество [Equation]P[/Equation]
следующим образом:

[Equation display:true]
\begin{aligned}
P &= (e : \bm 1) \\
{} &+ (i_1 : set(M) \setminus \{ unit(M)\}) \\
{} &+ (i_2 : set(N) \setminus \{ unit(N)\}) \\
{} &+ ((\cdot) : P \times P)
\end{aligned}
[/Equation]

Затем определим отношение эквивалентности [Equation]\sim[/Equation], как наименьшее отношение,
удволетворяющее условиям свободного моноида вместе со следующими условиями:

[Equation display:true]
\begin{aligned}
i_1(x) \cdot i_1(y) &\sim i_1(mul(M)(x, y)) \\
i_2(x) \cdot i_2(y) &\sim i_2(mul(N)(x, y)) \\
\end{aligned}
[/Equation]

И затем определяем искомый моноид как

[Equation display:true]
\begin{aligned}
M * N = (
  &P/{\sim},\\
  &([a]_\sim, [b]_\sim) \mapsto [a \cdot b]_\sim,\\
  &e
)
\end{aligned}
[/Equation]

Этот моноид называется *свободным произведением* моноидов [Equation]M[/Equation] и [Equation]N[/Equation]. Покажем, что он соответствует универсальному свойству для суммы:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywxLCJNKk4iXSxbMywzLCJaIl0sWzAsMCwiTSJdLFs2LDAsIk4iXSxbMiwwLCJpXzEiXSxbMywwLCJpXzIiLDJdLFsyLDEsImYiLDJdLFszLDEsImciXSxbMCwxLCJ1IiwxLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV1d&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Действительно:

[Equation display:true]
u = \begin{cases}
e &\mapsto unit(Z) \\
i_1(x) &\mapsto f(x) \\
i_2(x) &\mapsto g(x) \\
x \cdot y &\mapsto mul(Z)(u(x), u(y))
\end{cases}
[/Equation]

И снова единственность [Equation]u[/Equation] следует из коммутативности диаграммы и определения гомоморфизма.

## Категории
