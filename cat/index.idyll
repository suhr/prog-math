[meta title:"Теория категорий" /]

[Header
  fullWidth:true
  title:"Теория категорий"
/]

Теория категорий была создана как скромный инструмент для нужд алгебраической топологии. Теперь же
она захватила всю математику, успешно завоёвывает информатику и совершает регулярные набеги на
естественные науки.

Причина столь впечатляющей мощи проста и описывается одним словом: *абстракция*. Так же, как в
программировании мы описываем интерфейсы с помощью методов, в теории категорий мы описываем
алгебраические структуры с помощью функций. При этом, внутренняя стуктура объектов, между которыми
заданы функции, скрыта от нас.

[Aside]Кроме, пожалуй, C, Go и PHP.[/Aside]
Мы, программисты, находимся в довольно привелегированном положении. Категориальные понятия *уже*
даны нам в языках, подходах и культуре, хотя и не осознаются. И несмотря на многочисленные шутки
про непостижимость монад™, `flat_map` уже есть в каждом языке.

## Диаграммы

[Aside]
В математике обычно пишут композицию справо налево, как [Equation]g \circ f[/Equation]. Но мы читаем,
пишем и рисуем диаграммы слева направо, и потому так записывать композицию не будем.
[/Aside]
Но сначала посмотрим на функции между множествами ещё раз. Для начала, определим операцию компоцизии
функций:

[Equation display:true]
(f \mathbin\bm; g)(x) = g(f(x))
[/Equation]

И тождественную функцию из множества [Equation]A[/Equation] в само себя:

[Equation display:true]
(\forall x \in A)\enspace \mathrm{id}_A(x) = x
[/Equation]

Любая функция [Equation]f: A \to B[/Equation] имеет единицу слева и справо относительно композиции:

[Equation display:true]
\begin{aligned}
\mathrm{id}_{A} \mathbin\bm; f &= f \\
f \mathbin\bm; \mathrm{id}_{B} &= f \\
\end{aligned}
[/Equation]

И для любых трёх функций, их композиция ассоциативна (если определена):

[Equation display:true]
(f \mathbin\bm; g) \mathbin\bm; h = f \mathbin\bm; (g \mathbin\bm; h)
[/Equation]

Имея какие-то множества, мы можем рисовать функции как стрелочки между ними. Например:

[img src:"static/rzn.png" height:100 /]

Это называется диаграммой.

Для равенств, касающихся тождественных функций, мы тоже можем нарисовать диаграму:

[img src:"static/id_f.png" height:250 /]

Но чтобы диаграмма определяла равенства, нужно дополнительное условие. А именно: все пути,
соединяющие любые две вершины, равны. Диаграмма, обладающая подобным свойством,
называется *коммутативной*.

(правый и левый обратные)

## Категории

Неформально, категория это класс объектов с функциями между ними. Формально же,
категория [Equation]\mathsf C[/Equation] это:

1. Класс объектов [Equation]\operatorname{ob}(\mathsf C)[/Equation]
2. Для любой пары объектов [Equation]A[/Equation] и [Equation]B[/Equation], класс стрелок (морфизмов) [Equation]\operatorname{hom}(A, B)[/Equation]
3. Для каждого объекта, единичная стрелка [Equation]\mathrm{id}_A \in \operatorname{hom}(A, A)[/Equation]
4. Для любой пары стрелок [Equation]f \in \operatorname{hom}(A, B)[/Equation] и [Equation]g \in \operatorname{hom}(B, C)[/Equation], стрелка [Equation]f \mathbin\bm; g \in \operatorname{hom}(A, C)[/Equation]

[Aside]Мы будем писать [Equation]f: A \to B[/Equation] имея в виду [Equation]f \in \operatorname{hom}(A, B).[/Equation][/Aside]
Неравные классы стрелок не должны пересекаться. Кроме того, композиция стрелок должна вести себя
как композиция функций:

[Equation display:true]
\begin{aligned}
\mathrm{id}_{A} \mathbin\bm; f &= f \\
f \mathbin\bm; \mathrm{id}_{B} &= f \\
(f \mathbin\bm; g) \mathbin\bm; h &= f \mathbin\bm; (g \mathbin\bm; h)\\
\end{aligned}
\qquad\quad
\forall\left(\begin{aligned}
f &\in \operatorname{hom}(A, B) \\
g &\in \operatorname{hom}(B, C) \\
h &\in \operatorname{hom}(C, D)
\end{aligned}\right)
[/Equation]

При этом, стрелки вовсе не обязаны быть функциями. Они могут быть чем угодно, если выполнены
соответствующие условия.

Категория называется малой, если её классы объектов и классы стрелок — множества.

Очевидные примеры категорий:

[Aside]Точнее, класс эквивалетности чистых тотальных функций по действию на значения типа.[/Aside]

- Категория типов [Equation]\mathsf{Type}[/Equation], где объекты это типы, а стрелки это чистые тотальные функции
- Категория множеств [Equation]\mathsf{Set}[/Equation], где объекты — множества, а стрелки — отображения
- Категория векторных пространств [Equation]\mathsf{Vect}[/Equation], где объекты — векторные пространства, а стрелки — линейные отображения

Менее очевидные примеры:

- Категория [Equation]\mathsf{Set}_\subseteq[/Equation], где объекты — множества, а стрелки — отношение подмножества
- Категория [Equation]\Bbb N_{div}[/Equation], где объекты — натуральные числа, а стрелки — отношение делимости

В случае отношения неравенства, мы можем определить стрелки так:

[Equation display:true]
\operatorname{hom}(x, y) = \{(x, y) \mid x \leqslant y\}
[/Equation]

И из свойств отношения неравенства следуют требования, которым должна соответствовать категория:

[Equation display:true]
\begin{aligned}
x \leqslant x \\
x \leqslant y \mathbin\mathrm{and} y \leqslant z \implies x \leqslant z
\end{aligned}
\qquad
\begin{aligned}
\operatorname{id}_x &= (x, x) \\
(x, y) \mathbin\bm; (y, z) &= (x, z)
\end{aligned}
[/Equation]

Аналогично для отношений подмножества и делимости.

Диаграмма в [Equation]\Bbb N_{div}[/Equation] для чисел от нуля до девяти (без транзитивных стрелок):

[img src:"static/nat_div.png" height:500 /]

Стрелка из [Equation]x[/Equation] в [Equation]y[/Equation] соответствует
делимости [Equation]y[/Equation] на [Equation]x[/Equation] ([Equation]x[/Equation] делит [Equation]y[/Equation]).

### Обратная категория

Пусть у нас есть категория [Equation]\mathsf C[/Equation]. Мы можем построить обратную
категорию [Equation]\mathsf{C}^\mathsf{op}[/Equation], просто обратив направление всех стрелок.
При этом, все построения, что у нас были, превращаются в двойственные.

Конкретнее, обратная категория это категория с теми же объектами, где стрелки и композиция определены
следующим образом:

[Equation display:true]
\operatorname{hom}_{\mathsf{C}^\mathsf{op}}(A, B) = \operatorname{hom}_\mathsf{C}(B, A)
[/Equation]
[Equation display:true]
f \mathbin\bm;^\mathsf{op} g = g \mathbin\bm; f
[/Equation]

Этот нехитный трюк имеет фундаментальное значение:

1. У любого категориального понятия есть двойственное понятие
2. Если утверждение верно для всех категорий, то и двойственное утверждение верно для всех категорий

Примеры двойственных понятий:

- [Equation]\forall[/Equation] и [Equation]\exists[/Equation]
- [Equation]\mathbin\mathrm{and}[/Equation] и [Equation]\mathbin\mathrm{or}[/Equation]
- [Equation]\cap[/Equation] и [Equation]\cup[/Equation]
- `struct` и `enum`
- `()` и `!`
- И многое другое

### Виды стрелок

В теории множеств, у нас были инъективные, сюръективные и биективные функции, определённые так
по тому, как они действуют на элементы. В категориях же у нас никаких элементов нет, и аналогичные
понятия нужно определять немного иначе.

Проще всего определить аналог биективных функций.

Cтрелка [Equation]f: A \to B[/Equation] называется *изоморфизмом* (также: обратимой), если существует
такая стрелка [Equation]f^{-1}: B \to A[/Equation], что

[Equation display:true]
\begin{aligned}
f \mathbin\bm; f^{-1} &= \mathrm{id}_A \\
f^{-1} \mathbin\bm; f &= \mathrm{id}_B
\end{aligned}
[/Equation]

Два объекта [Equation]A[/Equation] и [Equation]B[/Equation] называются изоморфными
(пишется [Equation]A \cong B[/Equation]), если между ними существует изоморфизм.

С высоты теории категорий изоморфные объекты не особо отличимы: все свойства, определяемые через
стрелки у них одни и те же.

Чтобы определить аналог инъекции, достаточно вспомнить, что инъективной функции соответствует
биекция между областью функции и образом функции.

Стрелка [Equation]f[/Equation] называется *мономорфизмом*, если для любых двух
стрелок [Equation]g[/Equation] и [Equation]g^\prime[/Equation]:

[Equation display:true]
g \mathbin\bm; f = g^\prime \mathbin\bm; f \implies g = g^\prime
[/Equation]

Двойственно, стрелка [Equation]f[/Equation] называется *эпиморфизмом*, если для любых двух
стрелок [Equation]g[/Equation] и [Equation]g^\prime[/Equation]:

[Equation display:true]
f \mathbin\bm; g = f \mathbin\bm; g^\prime \implies g = g^\prime
[/Equation]

На диаграммах, мономорфизмы и эпиморфизмы обозначаются, соответственно,
как [Equation]A \xhookrightarrow{f} B[/Equation] и [Equation]A \xtwoheadrightarrow{f} B[/Equation].

Ещё стрелки:

- Эндоморфизмы — стрелки, у которых начало и конец совподают
- Автоморфизмы — обратимые эндоморфизмы

### Начальные и терминальные стрелки

Рассмотрим тип [std::convert::Infallible](https://doc.rust-lang.org/std/convert/enum.Infallible.html)

```rust
pub enum Infallible {}
```

Он обладает весьма интересным свойством:

```rust
use std::convert::Infallible;

/// По-сути, единственная функция из Infallible в A
fn anything<A>(never: Infallible) -> A {
    match never {}
}
```

Конкретнее:

1. Существует функция из `Infallible` в любой тип
2. Эта функция по-сути единственная

Начальный объект [Equation]\bm 0[/Equation] категории [Equation]\mathsf C[/Equation] это такой объект,
что для любого [Equation]Z \in \operatorname{ob}(\mathsf C)[/Equation] существует единственная
стрелка из [Equation]\bm 0[/Equation] в [Equation]Z[/Equation].

Примеры:

- В [Equation]\mathsf{Type}[/Equation] это любой пустой тип
- В [Equation]\mathsf{Set}[/Equation] это пустое множество
- В [Equation]\Bbb N_{div}[/Equation] это число 1

Мы написали [Equation]\bm 0[/Equation] так, будто такой объект единственнен, хотя это вообще говоря
не так. Однако, на это есть хорошая причина.

**Предложение:** между любыми двумя начальными объектами существует *единственный* изморфизм.

Пусть [Equation]I[/Equation] и [Equation]J[/Equation] — начальные объекты. По определению,
существуют единственные стрелки [Equation]i_J : I \to J[/Equation] и [Equation]j_I : J \to I[/Equation].
Их композиция это единственная стрелка из [Equation]I[/Equation] в [Equation]I[/Equation], то
есть [Equation]\mathrm{id}_{I}[/Equation]. То же самое и в другую сторону.

С высоты теории категорий, объекты с единственным изморфизмом почти неотличимы. Поэтому, мы будем
смело обозначать начальный объект как [Equation]\bm 0[/Equation].

Для любого понятия есть двойственное, и понятие начального объекта — не исключение.

Терминальный объект [Equation]\bm 1[/Equation] категории [Equation]\mathsf C[/Equation] это
такой объект, для любого [Equation]Z \in \operatorname{ob}(\mathsf C)[/Equation] существует единственная
стрелка из [Equation]Z[/Equation] в [Equation]\bm 1[/Equation].

Примеры:

- В [Equation]\mathsf{Type}[/Equation] это любой тип с единственным значением
- В [Equation]\mathsf{Set}[/Equation] это любое множество с единственным элементом
- В [Equation]\Bbb N_{div}[/Equation] это число 0

Мы можем выразить начальные и конечные стрелки как трейт:

```rust
use std::convert::Infallible;

trait Initial {
    /// Единственная функция из A в self
    fn never<A>(self) -> A;
}

trait Terminal {
    /// Единственно возможная функция из self в A
    fn unit<A>(_: A) -> Self;
}

impl Initial for Infallible {
    fn never<A>(self) -> A {
        match self {}
    }
}

impl Terminal for () {
    fn unit<A>(_: A) { () }
}
```

При этом, компилятор может гарантировать единственность начальной стрелки, а проверять единственность
терминальной стрелки необходимо программисту.

### Произведение

Рассмотрим тип

```rust
struct Pair<A, B> {
    first: A,
    second: B,
}
```

`first` и `second` можно рассматривать как функции из `Pair<A, B>` в `A` и `B` соответственно.
Если у нас есть функция из какого-то типа `Z` в `Pair<A, B>`, то существуют функции из `Z` в
`A` и из `Z` в `B`.

Но пусть `f` — функция из `Z` в `A`, а `g` — функция из `Z` в `B`. Тогда существует по-сути
единственная соответствующая им функция из `Z` в `Pair<A, B>`:

```rust
fn pair_fg(something: Z) -> Pair<A, B> {
    Pair {
        first: f(something),
        second: g(something),
    }
}
```

Произведение объектов [Equation]A[/Equation] и [Equation]B[/Equation] это
некий объект [Equation]A \times B[/Equation], снабжённый стрелками [Equation]\pi_1: A \times B \to A[/Equation]
и [Equation]\pi_2: A \times B \to B[/Equation], что для любых двух
стрелок [Equation]f: Z \to A[/Equation] и [Equation]g: Z \to B[/Equation] существует *единственная*
стрелка [Equation]f\times g: Z \to A \times B[/Equation], для которой крыло коммутативно:

[img src:"static/prod.png" height:300 /]

Примеры:

- В [Equation]\mathsf{Type}[/Equation] это структуры и кортежи
- В [Equation]\mathsf{Set}[/Equation] это декартово произведение множеств
- В [Equation]\mathsf{Set}_\subseteq[/Equation] это пересечение множеств
- В [Equation]\Bbb N_{div}[/Equation] это наибольший общий делитель

Последнее следует из того, что [Equation]A \times B[/Equation] это терминальный объект в категории
объектов, снабжённых проекциями в [Equation]A[/Equation] и [Equation]B[/Equation].

Конкретнее, для категории [Equation]\mathsf C[/Equation] определим
категорию [Equation]\mathsf C_{AB}[/Equation], где объекты определяем так:

[Equation display:true]
\operatorname{ob}_{\mathsf C_{AB}} = \{
(P, p_1, p_2) \mid
p_1 \in \operatorname{hom}_\mathsf{C}(P, A) \mathbin\mathrm{and}
p_2 \in \operatorname{hom}_\mathsf{C}(P, B)
\}
[/Equation]

Объект как диаграмма:

[img src:"static/pab.png" height:250 /]

Стрелки [Equation]\operatorname{hom}_{\mathsf C_{AB}}(P, Q)[/Equation] же это все стрелки [Equation]f: P \to Q[/Equation],
для которых диаграмма коммутирует:

[img src:"static/pq.png" height:300 /]

[Aside]Но в реальном коде так делать *не нужно*.[/Aside]
Наличие функций как первоклассных объектов позволяет выразить произведение как трейт:

```rust
trait Product<A, B> {
    fn first(self) -> A;
    fn second(self) -> B;

    fn times<Z: 'static + Copy>(f: fn(Z) -> A, g: fn(Z) -> B)
        -> Box<dyn Fn(Z) -> Self>;
}

struct Pair<A, B> {
    first: A,
    second: B,
}

impl<A: 'static, B: 'static> Product<A, B> for Pair<A, B> {
    fn first(self) -> A {
      self.first
    }

    fn second(self) -> B {
      self.second
    }

    fn times<Z: 'static + Copy>(f: fn(Z) -> A, g: fn(Z) -> B)
        -> Box<dyn Fn(Z) -> Self>
    {
        Box::new(move |z| Pair {
            first: f(z),
            second: g(z),
        })
    }
}
```

### Копроизведение

Копроизведение — понятие, двойственное произведению.

Копроизведение объектов объектов [Equation]A[/Equation] и [Equation]B[/Equation] это
объект [Equation]A + B[/Equation], снабжённый стрелками [Equation]i_1: A \to A + B[/Equation]
и [Equation]i_2: B \to A + B[/Equation], что для любых двух стрелок [Equation]f: A \to Z[/Equation]
и [Equation]g: B \to Z[/Equation] существует *единственная* стрелка [Equation]f + g: A + B \to Z[/Equation],
для которой кокрыло коммутативно:

[img src:"static/sum.png" height:300 /]

Аналогично произведению, копроизведение это начальный объект в категории объектов, снабжённых
вложениями из [Equation]A[/Equation] и [Equation]B[/Equation].

В [Equation]\mathsf{Type}[/Equation] копроизведение это тип-сумма, например, `Either<A, B>` или `Result<T,  E>`.
В [Equation]\mathsf{Set}[/Equation] это размеченное объединение:

[Equation display:true]
A \sqcup B = (\{0\} \times A) \cup (\{1\} \times B)
[/Equation]

В [Equation]\mathsf{Set}_\subseteq[/Equation] копроизведение это объединение множеств, когда же
в [Equation]\Bbb N_{div}[/Equation] это наименьшее общее кратное.

(про типы суммы)

### Расслоёное произведение и сумма

Пересечение множеств это произведение в категории [Equation]\mathsf{Set}_\subseteq[/Equation]. Но
мы можем определить аналог пересечения и в категории [Equation]\mathsf{Set}[/Equation].

Пусть [Equation]A, B \subseteq U[/Equation]. Есть две фунции:

- Вложение [Equation]a_U : A \to U[/Equation]
- Вложение [Equation]b_U : B \to U[/Equation]

Если мы рассматриваем [Equation]A \cap B[/Equation], то к этим функциям добавляются ещё две:

- Вложение [Equation]\pi_A : A \cap B \to A[/Equation]
- Вложение [Equation]\pi_B : A \cap B \to B[/Equation]

И все они на коммутативной диаграмме:

[img src:"static/a_cap_b.png" height:250 /]

Расслоёное произведение стрелок [Equation]f : A \to C[/Equation] и [Equation]g : B \to C[/Equation] это:

[ul]
[li]Объект [Equation]A \times_C B[/Equation]
[ul][li]Вместе со стрелками [Equation]\pi_1: A \times_C B \to A[/Equation] и [Equation]\pi_2: A \times_C B \to B[/Equation][/li][/ul]
[/li]
[li]Такой что для любых двух стрелок [Equation]z_A: Z \to A[/Equation] и [Equation]z_B: Z \to B[/Equation]
[ul][li]Существует единственная стрелка [Equation]u: Z \to A \times_C B[/Equation] для которой следующая диаграмма коммутирует:[/li][/ul]
[/li]
[/ul]

[img src:"static/pullback.png" height:400 /]

В категории множеств, расслоёное произведение это следующее множество:

[Equation display:true]
A \times_C B = \{(a, b) \in A \times B \mid f(a) = g(b)\}
[/Equation]

Если мы посмотрим на диаграмму для пересечения множеств с другой стороны, мы получим диаграмму
для объединения множеств:

[img src:"static/a_cup_b.png" height:250 /]

Расслоённая сумма стрелок [Equation]f : Z \to A[/Equation] и [Equation]g : Z \to B[/Equation]
это расслоённое произведение в обратной категории.

Не будем расписывать определение подробно: идея в точности та же, что и в случае копроизведения.

В категории множеств, расслоёная сумма это множество [Equation](A \sqcup B)/{\sim}_{f \sqcup g}[/Equation],
где [Equation]{\sim}_{f \sqcup g}[/Equation] это отношение эквивалентности, порождённое функцией

[Equation display:true]
\begin{aligned}
(f \sqcup g)((0, a)) &= f(a) \\
(f \sqcup g)((1, b)) &= g(b)
\end{aligned}
[/Equation]

## Функторы

Функтор это отображение между категориями. Конкретнее, функтор [Equation]F: \mathsf C \to \mathsf D[/Equation]
это сущность, которая:

- Сопоставляет объекту [Equation]X \in \operatorname{ob}(\mathsf C)[/Equation] объект [Equation]F(X) \in \operatorname{ob}(\mathsf D)[/Equation]
- Сопоставляет стрелке [Equation]f \in \operatorname{hom}_\mathsf{C}(X, Y)[/Equation] стрелку [Equation]F(f) \in \operatorname{hom}_\mathsf{C}(F(X), F(Y))[/Equation]

Причём сохраняя единичные стрелки и композицию:

[Equation display:true]
\begin{aligned}
F(\mathrm{id}_X) &= \mathrm{id}_{F(X)} \\
F(f \mathbin\bm; g) &= F(f) \mathbin\bm; F(g)
\end{aligned}
[/Equation]

Контравариантный функтор из [Equation]\mathsf C[/Equation] в [Equation]\mathsf D[/Equation] это
функтор [Equation]F: \mathsf C^\mathsf{op} \to \mathsf D[/Equation].

Примеры

[ul]
[li]`Option<T>`, `Vec<T>`, `Iterator`, `Future`, etc...[/li]
[li]Все функции, сохраняющие отношение порядка это функторы между соответствующими категориями.
В частности:
[ul]
    [li]`floor()` и `ceil()`[/li]
    [li]Топологическая сортировка[/li]
    [li]Логические часы[/li]
[/ul]
[/li]
[li]Выделение компонент сильной связности[/li]
[li]Направленный граф[/li]
[li]Диаграмма[/li]
[li]В линейной алгебре, двойственное отображение [Equation](\_)^*[/Equation][/li]
[/ul]

Понятие фукторы позволяют определить категорию малых категорий [Equation]\mathsf{Cat}[/Equation],
где объекты — малые категории, а стрелки — функторы между категориями.

### Диаграммы и графы

Идея очень проста: пусть у нас есть некий элемент [Equation]e \in S[/Equation]. Этому элементу
соответствует единственная функция [Equation]e^\bullet: \bm 1 \to S[/Equation]:

[Equation display:true]
e^\bullet(\bullet) = e
[/Equation]

Продолжая аналогию, объекту [Equation]A \in \operatorname{ob}(\mathsf C)[/Equation] соответствует
единственный функтор [Equation]A^\bullet : \bm 1 \to \mathsf C[/Equation],
где [Equation]\bm 1[/Equation] уже не множество с единственным элементом, а категория с единственным
объектом и единственной стрелкой.

Продолжая аналогию дальше, вот это

[img src:"static/afb.png" height:100 /]

по-сути является функтором из вот этого в [Equation]\mathsf C[/Equation]

[img src:"static/p_p.png" height:100 /]

Обобщая, диаграмма это функтор из некой категории [Equation]\mathsf J[/Equation] (называемой *схемой*
или категорий индексов) в категорию [Equation]\mathsf C[/Equation].

Этот казалось бы бесполезное построение на самом деле даёт нам абстракцию: мы можем говорить про все
диаграммы из данной схемы, или даже говорить про все диаграммы вообще. Причём говорить на нативном
языке теории категории, языке стрелок.

Итак, диаграмма это функтор, а что насчёт направленных графов? А направленный граф это:

- Множество вершин [Equation]V[/Equation]
- Вместе с множество рёбер [Equation]E[/Equation]
- И функциями [Equation]src: E \to V[/Equation] и [Equation]tgt: E \to V[/Equation], возвращающими начало и конец ребра

Всё это можно легко изобразить диаграммой:

[img src:"static/e_v.png" height:100 /][br /]

Но диграмма это функтор! И стало быть, направленный граф это тоже всего лишь функтор из схемы
с двумя объектами и стрелками в категорию множеств.

### Пределы и копределы

Определения декартова произведения и расслоёного произведения состоят в основном из бойлерплейта:
мы говорим почти одни и те же слова, разве что диаграммы немного разные. Но зная, что диаграмма
это функтор, мы можем обобщить обычные и расслоёные произведения до понятия предела диаграммы.

Для этого нам сначала нужно построить категорию, в которой искомый предел является терминальным
объектом. В случае расслоёного произведения, это категория таких вот конус:

[img src:"static/fibred_cone.png" height:350 /]

Мы присоединили [Equation]A \times_C B[/Equation] ко всем остальным объектам и приказали диаграмме
коммутировать.

В общем случае, для диаграммы [Equation]F: \mathsf J \to \mathsf C[/Equation] конус это
объект [Equation]N \in \operatorname{ob}(\mathsf C)[/Equation] вместе с семейством стрелок [Equation]\varphi_X : N \to F(X)[/Equation],
причём для любых [Equation]X \in \operatorname{ob}(\mathsf J)[/Equation], [Equation]Y \in \operatorname{ob}(\mathsf J)[/Equation] и [Equation]f: X \to Y[/Equation]
следующая диаграмма коммутирует:

[img src:"static/cone.png" height:250 /]

Стрелка между конусами [Equation](P, \psi_X)[/Equation] и [Equation](N, \varphi_X)[/Equation] это
стрелка [Equation]u: P \to N[/Equation], такая, что для любого [Equation]X \in \operatorname{ob}(\mathsf J)[/Equation]
следующая диаграмма коммутирует:

[img src:"static/cone_arr.png" height:175 /]

Предел диаграммы [Equation]F: \mathsf J \to \mathsf C[/Equation] это терминальный объект в категории
конусов для [Equation]F[/Equation]. Соответствующий объект обозначается [Equation]\operatorname{lim} F[/Equation].

Двойственно, копредел диаграммы это начальный объект в категории коконусов. Коконусы определяются
так же, как и конусы, только стрелки направлены в противоположную сторону.

(TODO: ещё про пределы)

### Естественные преобразования

Если функторы это стрелки между категориями, то естественные преобразования это стрелки между функторами.

Пусть [Equation]F : \mathsf{C} \to \mathsf{D}[/Equation] и [Equation]D : \mathsf{C} \to \mathsf{D}[/Equation] — функторы.
Естественное преобразование [Equation]\alpha : F \Rightarrow G[/Equation] это сущность, сопоставляющая
каждому объекту [Equation]X \in \operatorname{ob}(\mathsf C)[/Equation] стрелку [Equation]\alpha_X : F(X) \to G(X)[/Equation],
причём для любой стрелки [Equation]f : X \to Y[/Equation] следующая диаграмма коммутирует:

[img src:"static/nat.png" height:250 /][br /]

Примеры:

- Полиморфные функции между типами-функторами, если результат не зависит от того, применятся ли `map` перед или после функции. Например `append` или `reverse`.
- Гомоморфизмы между графами
- В линейной алгебре, естественный изоморфизм [Equation]\bm 1 \cong (\_)^{**}[/Equation]

Композиция двух естественных преобразований [Equation]\alpha : F \Rightarrow G[/Equation] и [Equation]\beta : G \Rightarrow H[/Equation]
определяется просто:

[img src:"static/nat_comp.png" height:450 /][br /]

Доказательство естественности:

[Aside]Не нужно пытаться понять это символьно. Смотри на диаграмму, она содержит все ответы.[/Aside]
[Equation display:true]
\alpha_X \mathbin\bm; \beta_X \mathbin\bm; H(f) =
\alpha_X \mathbin\bm; G(f) \mathbin\bm; \beta_Y =
F(f) \mathbin\bm; \alpha_Y \mathbin\bm; \beta_Y
[/Equation]

Естественные преобразования позволяют нам определить категорию функторов [Equation][\mathsf C, \mathsf D][/Equation],
где объекты — функторы между [Equation]\mathsf C[/Equation] и [Equation]\mathsf D[/Equation],
а стрелки — естественные преобразования между функторами.

Понятие естественного преобразования позволяет ещё более кратко выразить понятие предела. Чтобы
это сделать, сначала нарисуем диаграмму для конуса чуть иначе:

[img src:"static/lim_sq.png" height:250 /][br /]

Чтобы превратить этот квадрат в определение естественного преобразования, определим для
каждого [Equation]N \in \operatorname{ob}(\mathsf C)[/Equation]
функтор [Equation]\Delta_N : \mathsf J \to \mathsf C[/Equation] такой что для любого
объекта [Equation]X \in \operatorname{ob}(\mathsf J)[/Equation] и любой стрелки [Equation]f : X \to Y[/Equation]:

[Equation display:true]
\begin{aligned}
\Delta_N(X) &= N \\
\Delta_N(f) &= \mathrm{id}_N
\end{aligned}
[/Equation]

Тогда семейство стрелок [Equation]\varphi_X[/Equation] это ничто иное, как естественное преобразование
[Equation]\varphi : \Delta_N \Rightarrow F[/Equation].

[Aside]Этот функтор называется диагональным.[/Aside]
Далее, определим функтор [Equation]\Delta : \mathsf C \to [\mathsf J, \mathsf C][/Equation]
такой что для любого объекта [Equation]N \in \operatorname{ob}(\mathsf C)[/Equation] и любой
стрелки [Equation]f : N \to P[/Equation]

[Equation display:true]
\begin{aligned}
\Delta(N) &= \Delta_N \\
\Delta(f) &= f
\end{aligned}
[/Equation]

Здесь [Equation]f[/Equation] становится естественным преобразованием из [Equation]\Delta_N[/Equation] в [Equation]\Delta_P[/Equation]:

[img src:"static/del_np.png" height:250 /][br /]

Нам осталось лишь определить категорию, где мы всем этим воспользоваться.
Пусть [Equation]A \in \operatorname{ob}(\mathsf C)[/Equation] — некий фиксированный объект,
а [Equation]F : \mathsf D \to \mathsf C[/Equation] — функтор. Категория [Equation]F \downarrow \gray A[/Equation] стрелок
из [Equation]F[/Equation] в [Equation]A[/Equation] это следующая категория:

[Equation display:true]
\begin{aligned}
\operatorname{ob}(F \downarrow \gray A) &= \{
    (X, h) \mid X \in \operatorname{ob}(\mathsf D) \mathbin\mathrm{and}
    h \in \operatorname{hom}_\mathsf{C}(F(X), A) \} \\
\operatorname{hom}_{F \downarrow \gray A}((X, h), (Y, h')) &= \{
    F(f) \mid f \in \operatorname{hom}_\mathsf{D}(X, Y) \mathbin\mathrm{and}
    h \mathbin\bm; F(f) = h'\}
\end{aligned}
[/Equation]

Стрелка между двумя объектами как диаграмма:

[img src:"static/f_to_a.png" height:250 /][br /]

Теперь мы полностью готовы ещё раз определить предел диаграммы. Итак, предел
диаграммы [Equation]F : \mathsf J \to \mathsf C[/Equation] это терминальный
объект в категории [Equation]\Delta \downarrow \gray F[/Equation].

Когда уровень абстракции становится слишком высок, полезно сделать шаг назад. Подставим
конкретные [Equation]P[/Equation] и [Equation]N[/Equation] в диаграмму для [Equation]\Delta \downarrow \gray F[/Equation]:

[img src:"static/del_p_n.png" height:175 /][br /]

Это уже знакомая нам диаграмма для стрелки между конусами, только в виде функторов и естественных
преобразований.

### 2-категории

В обычной категории у нас есть объекты и стрелки между ними. В случае же [Equation]\mathsf{Cat}[/Equation]
у нас есть ещё и стрелки между стрелками (2-стрелки). И хотя стрелки между стрелками и не входят в определение
категории, ничто не мешает нам показать их на диаграмме:

[img src:"static/fga.png" height:250 /]

Ещё у нас есть вертикальная композиция 2-стрелок:

[img src:"static/vert.png" height:250 /]

Однако, на плоскости есть два направления. И две 2-стрелки могут соприкасаться иначе:

[img src:"static/horiz.png" height:200 /]

Эта ситуация предлагает понятие горизонтальной композиции
[Equation]\alpha * \beta : (F \mathbin\bm; H) \Rightarrow (G \mathbin\bm; K)[/Equation].

Чтобы опрелелить горизонтальную композицию, заметим, что [Equation]\alpha_X : F(X) \to G(X)[/Equation]
это обычная 1-стрелка. И так как [Equation]\beta[/Equation] — естественное преобразование,
следующая диаграмма должна коммутировать:

[img src:"static/horiz_nat.png" height:250 /]

Отсюда у нас есть целых два равных определений горизонтальной композиции естественных преобразований:

[Equation display:true]
(\alpha * \beta)_X = H(\alpha_X) \mathbin\bm; \beta_{G(X)} = \beta_{F(X)} \mathbin\bm; K(\alpha_X)
[/Equation]

Символьно эти выражения выглядят несколько мудрёно, но для них есть простая визуальная аналогия.
В первом случае, мы как-бы переносим [Equation]\alpha[/Equation] вдоль [Equation]H[/Equation],
ставя его над [Equation]\beta[/Equation]:

[img src:"static/horiz_above.png" height:250 /]

Во втором же случае, мы как-бы переносим [Equation]\alpha[/Equation] вдоль [Equation]K[/Equation],
ставя его под [Equation]\beta[/Equation].

Мы определили композицию, но ещё не доказали, что результат является естественным преобразованием.
Чтобы доказать, возьмём [Equation]f : X \to Y[/Equation] и начертим следующую диаграмму:

[img src:"static/horiz_valid.png" height:450 /][br /]

Она коммутирует: верхний квадрат потому, что [Equation]H[/Equation] — функтор,
а [Equation]\alpha[/Equation] — естественное преобразование, нижний квадрат потому,
что [Equation]\beta[/Equation] — естественное преобразование, а вся диаграмма — потому, что квадраты.

Хотя у нас есть целых две композиции, этого недостаточно, чтобы свободно чертить 2-диаграммы.
Например, пусть диаграмма выглядит так:

[img src:"static/hv.png" height:250 /]

Это [Equation](\alpha \mathbin\bm; \beta) * (\gamma \mathbin\bm; \delta)[/Equation]
или [Equation](\alpha * \gamma) \mathbin\bm; (\beta * \delta)[/Equation]?

К счастью, нам не нужно выбирать какой-то один из вариантов, потому что оба равны. И вот почему:

[img src:"static/hv_eq.png" height:650 /]

Диаграмма коммутирует, ибо [Equation]\gamma[/Equation] — естественное преобразование.

Теперь у нас всё готово, чтобы ввести новый тип категорий — 2-категории.

Строгая 2-категория это:

- Объекты
- 1-стрелки между объектами
- 2-стрелки между 1-стрелками
- Целых три композиции: [Equation]F \mathbin \bm; G[/Equation] для 1-стрелок, [Equation]\alpha \bm; \beta[/Equation] и [Equation]\alpha * \beta[/Equation] для 2-стрелок

При этом:

[ul]
[li]Различные множества n-стрелок не пересекаются[/li]
[li]Для каждого объекта [Equation]\mathsf C[/Equation] есть единичная
1-стрелка [Equation]\mathrm{id}_\mathsf{C}[/Equation], а для каждой 1-стрелки [Equation]F[/Equation]
есть единичная 2-стрелка [Equation]\mathrm{id}_F[/Equation][/li]
[Aside]Доказательство ассоциативности [Equation]\bm;[/Equation] и [Equation]*[/Equation] оставлено
читателю в качестве упражнения.

Четвёртый закон называется 2-ассоциативностью.[/Aside]
[li]
Выполняются четыре закона ассоциативности:
[/li]
[/ul]

[Equation display:true]
\begin{aligned}
(F \mathbin\bm; G) \mathbin\bm; H &= F \mathbin\bm; (G \mathbin\bm; H) \\
(\alpha \mathbin\bm; \beta) \mathbin\bm; \gamma &= \alpha \mathbin\bm; (\beta \mathbin\bm; \gamma) \\
(\alpha * \beta) * \gamma &= \alpha * (\beta * \gamma) \\
(\alpha \mathbin\bm; \beta) * (\gamma \mathbin\bm; \delta) &=
(\alpha * \gamma) \mathbin\bm; (\beta * \delta)
\end{aligned}
[/Equation]

Основной (и для нас — единственный) пример строгой 2-категории это категория [Equation]\mathsf{Cat}[/Equation], ради которой мы всё это и затеяли.

Для 2-категорий есть два типа диаграм. Первый тип мы уже знаем — это обычные диаграммы,
где объекты это точки, 1-стрелки это стрелки, а 2-стрелки это области. Второй тип диаграмм это
струнные диаграммы. В них размерности перевёрнуты: объекты это области, 1-стрелки это линии,
разделяющие области, а 2-стрелки — точки, в которые сходятся линии.

Например, пусть есть такая диаграмма:

[img src:"static/triangle.png" height:250 /]

Соответствующая её струнная диаграмма выглядит так:

[img src:"static/string.png" height:250 /]

На струнной диаграмме единичные стрелки не рисуют. Например, диаграмма
для естественного преобразования [Equation]\mathrm{id}_F[/Equation] выглядит так:

[img src:"static/nat_id_f.png" height:150 /][br /]

А диаграмма для преобразования [Equation]\eta : F \Rightarrow id_\mathsf{C}[/Equation] — вот так:

[img src:"static/eta.png" height:250 /]

Причина, почему единичные стрелки не рисуют, проста:

[img src:"static/equals.png" height:200 /]

В этом вся магия струнных диаграмм: вместо того, чтобы переставлять символы, мы просто двигаем точки
вдоль линий. При этом, уравнения по-сути решают себя сами.

### Функтор hom

## Сопряжённые функторы

Рассмотрим вложение [Equation]i : \Bbb Z \to \Bbb R[/Equation], отображающее
каждое целое число в равное ему вещественное число. Эта функция инъективна, но не сюръективна.
Это означает, что правых обратных функций у неё может быть много:

[Equation display:true]
\begin{aligned}
\lfloor r \rfloor &= \operatorname{max}\ \{x \in \Bbb Z \mid x \leqslant r\} \\
\lceil r \rceil &= \operatorname{min}\ \{x \in \Bbb Z \mid x \geqslant r\} \\
\lceil r \rfloor &= \begin{cases}
\lfloor r \rfloor\quad r \geqslant 0 \\
\lceil r \rceil\quad r < 0
\end{cases}
\end{aligned}
[/Equation]

Но только одна из них обладает следующим свойством:

[Equation display:true]
i(n) \leqslant r \iff n \leqslant \lfloor r \rfloor
[/Equation]

У этой идеи есть категориальное обобщение. Пусть [Equation]F : \mathsf C \to \mathsf D[/Equation].
Функтор [Equation]G : \mathsf D \to \mathsf C[/Equation] называется правым сопряжённым к [Equation]F[/Equation],
если

[Aside]Изоморфизм функторов [Equation]\mathsf C^\mathsf{op} \times \mathsf D \to \mathsf{Set}[/Equation][/Aside]
[Equation display:true]
\operatorname{hom}(F(\_), \_) \cong \operatorname{hom}(\_, G(\_))
[/Equation]

Двойственно, [Equation]G[/Equation] называется левым сопряжённым к [Equation]F[/Equation]. Пара
сопряжённых функторов обозначается как [Equation]F \vdash G[/Equation].

### Экспоненциальный объект

### Единица и коединица

### Моноид в категории эндофунктороов
