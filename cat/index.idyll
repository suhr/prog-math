[meta title:"Теория категорий" /]

[Header
  fullWidth:true
  title:"Теория категорий"
/]

Теория категорий была создана как скромный инструмент для нужд алгебраической топологии. Теперь же
она захватила всю математику, успешно завоёвывает информатику и совершает регулярные набеги на
естественные науки.

Причина столь впечатляющей мощи проста и описывается одним словом: *абстракция*. Так же, как в
программировании мы описываем интерфейсы с помощью методов, в теории категорий мы описываем
алгебраические структуры с помощью функций. При этом, внутренняя стуктура объектов, между которыми
заданы функции, скрыта от нас.

[Aside]Кроме, пожалуй, C, Go и PHP.[/Aside]
Мы, программисты, находимся в довольно привелегированном положении. Категорные понятия *уже*
даны нам в языках, подходах и культуре, хотя и не осознаются. И несмотря на многочисленные шутки
про непостижимость монад™, `flat_map` уже есть в каждом языке.

## Алгебраические структуры

Перед тем, как погружаться в категории, рассмотрим базовые алгебраические структуры.

### Функции

Но сначала вспомним функции над множествами. Как мы знаем, функция [Equation]f: A \to B[/Equation] это
сущность, которая сопоставляет каждому элементу множества [Equation]A[/Equation] некий единственный
элемент множества [Equation]B[/Equation]. Равенство двух функций определяется равенством их областей,
кообластей и графиков.

[Aside]
В математике обычно пишут композицию справо налево, как [Equation]g \circ f[/Equation]. Но мы читаем,
пишем и рисуем диаграммы слева направо, и потому так записывать композицию не будем.
[/Aside]
Композиция функций [Equation]f: A \to B[/Equation] и [Equation]g: B \to C[/Equation] определяется
следующим образом:

[Equation display:true]
(f \mathbin\bm; g)(x) = g(f(x))
[/Equation]

Для любого множества [Equation]A[/Equation] существует единичное отображение из [Equation]A[/Equation] в [Equation]A[/Equation]:

[Equation display:true]
\mathrm{id}_A(x) = x 
[/Equation]

Для него верно следующее:

[Equation display:true]
\mathrm{id}_A \mathbin\bm; f = f \mathbin\bm; \mathrm{id}_B = f
[/Equation]

Кроме того, композиция трёх функций ассоциативна (если определена):

[Equation display:true]
(f \mathbin\bm; g) \mathbin\bm; h = f \mathbin\bm; (g \mathbin\bm; h)
[/Equation]

Ассоциативность позволяет нарисовать диаграмму для композиции функций:

[div style:`{ "width": "80%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMSwwLCJCIl0sWzAsMCwiQSJdLFsyLDAsIkMiXSxbMywwLCJEIl0sWzEsMCwiZiJdLFswLDIsImciXSxbMiwzLCJoIl1d&embed"
height:150 width:500
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Но мы можем использовать диаграммы не только чтобы выразить существование функции между двумя множествами.
Равенства функций тоже можно выразить как диаграмму. Например, [Equation]f \mathbin\bm; \mathrm{id}_B = f[/Equation] можно нарисовать так:

[div style:`{ "width": "70%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMCwxLCJBIl0sWzIsMSwiQiJdLFsyLDAsIkIiXSxbMCwxLCJmIiwyXSxbMCwyLCJmIl0sWzIsMSwiXFxtYXRocm17aWR9X0IiXV0=&embed"
height:300 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Диаграмма, в которой равны все функции, соответствующие направленным путям между любыми двумя заданными вершинами,
называется коммутативной. Также говорят, что диаграмма коммутирует.

Функция [Equation]f^{-1}[/Equation] называется обратной к [Equation]f: A \to B[/Equation],
если [Equation]f \mathbin\bm; f^{-1} = \mathrm{id}_A[/Equation] и [Equation]f^{-1} \mathbin\bm; f = \mathrm{id}_B[/Equation].
Как мы знаем, функция имеет обратную тогда и только тогда, когда она биективна.

Но для инъективных и сюръективных функцих есть более слабый вариант понятия обратной функции. Пусть
следующая диаграмма коммутирует:

[div style:`{ "width": "65%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMiwwLCJBIl0sWzEsMCwiQiJdLFswLDAsIkEiXSxbMSwwLCJnIl0sWzIsMSwiZiJdLFsyLDAsIlxcbWF0aHJte2lkfV9BIiwyLHsiY3VydmUiOjJ9XV0=&embed"
height:150 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Тогда функция [Equation]f[/Equation] называется левой обратной к функции [Equation]g[/Equation], а
функция [Equation]g[/Equation] называется правой обратной к функции [Equation]f[/Equation].

**Утверждение:** в этом случае [Equation]f[/Equation] инъективна, а [Equation]g[/Equation] — сюръективна.

Действительно, пусть [Equation]a \in A[/Equation]. Тогда имеем:

[Equation display:true]
a \xmapsto{f} b \xmapsto{g} a
[/Equation]

Так как [Equation]a[/Equation] произвольно, [Equation]g[/Equation] должна быть сюръекцией. Так
как [Equation]b[/Equation] соответствует единственное [Equation]a[/Equation], то [Equation]f[/Equation] инъективна.

Пусть [Equation]\bm 0 = \varnothing[/Equation], а [Equation]\bm 1 = \{\varnothing\}[/Equation].
Каждому множеству [Equation]A[/Equation] соответствует функция из [Equation]\bm 0[/Equation] в [Equation]A[/Equation],
и единственная функция из [Equation]A[/Equation] в [Equation]\bm 1[/Equation]. Каждому же [Equation]x \in A[/Equation]
соответствует единственная функция [Equation]\underline{x}: \bm 1 \to A[/Equation].

Это позволяет выразить применение функции как композицию:

[Equation display:true]
\underline 2 \mathbin\bm; sq = \underline 4 \qquad sq(x) = x^2
[/Equation]

Каждой функции [Equation]f: A \times B \to C[/Equation] соответствуют единственная функция
[Equation]g: A \to (B \to C)[/Equation]:

[Equation display:true]
g(x) = y \mapsto f(x, y)
[/Equation]

Мы будем писать [Equation]f(x, \_)[/Equation] имея в виду [Equation]y \mapsto f(x, y)[/Equation].
При этом [Equation]f(\_, \_)[/Equation] это то же, что и [Equation](x, y) \mapsto f(x, y)[/Equation].

### Отношение порядка

Отношение [Equation](\leqslant) : S \times S \to \bm 2[/Equation] называется отношением предпорядка,
если оно удволетворяет следующим аксиомам:

- Рефлексивность: [Equation](\forall x \in S)\enspace s \leqslant s[/Equation]
- Транзитивность: [Equation](\forall x, y, z \in S)\enspace x \leqslant y \mathbin\mathrm{and} y \leqslant z \implies x \leqslant z[/Equation]

Отношение предпорядка называется отношением порядка, если дополнительно выполняется

- [Equation](\forall x, y \in S)\enspace x \leqslant y \mathbin\mathrm{and} y \leqslant x \implies x = y[/Equation] (антисимметричность)

Отношение порядка называется линейным, если к тому же [Equation](\forall x, y \in S)\enspace x \leqslant y \mathbin\mathrm{or} y \leqslant x[/Equation] (иначе говоря, любые два элемента сравнимы).

Примеры отношения предпорядка:

- Существование пути в направленном графе между двумя узлами

Примеры отношения порядка:

- Обычное отношение порядка на числах
- Отношение подмножества
- Мощность множеств

Упорядоченное множество это множество с заданым на нём отношением порядка. Формально это пара [Equation](S, \leqslant)[/Equation].
Для этой пары определим проекции:

[Equation display:true]
\begin{aligned}
set((S, \_)) &= S \\
rel((\_, \leqslant)) &= (\leqslant)
\end{aligned}
[/Equation]

Мы будем писать [Equation]x \in S_{\leqslant}[/Equation] имея в виду [Equation]x \in set(S_{\leqslant})[/Equation].

Если посмотреть внимательнее на аксиомы отношения предпорядка, можно заметить сходство со свойствами
композиции. Сходство не случайное: отношение порядка можно представить как множество функций.

Конкретнее, определим множество

[Equation display:true]
\mathrm{arr}(x, y) = \{f : \{x\} \to \{y\} \mid x \leqslant y \}
[/Equation]

Посмотрим на элементы [Equation]\mathrm{arr}(x, x)[/Equation] как на абстракные стрелки из [Equation]x[/Equation] в [Equation]y[/Equation]:

[Equation display:true]
\begin{aligned}
\exists id_x &\in \mathrm{arr}(x, x) \qquad (\forall x \in S) \\
\exists f_{xy} \mathbin\bm; f_{yz} &\in \mathrm{arr}(x, z) \qquad (\forall f_{xy} \in \mathrm{arr}(x, y), f_{yz} \in \mathrm{arr}(y, z))
\end{aligned}
[/Equation]

Тождественная стрелка соответствует рефлексивности, когда же композиция соответствует транзитивности.

[Aside]Такие диаграммы называются диаграммами Хассе, и их рисуют так, чтобы все стрелки были направленны вверх.
При этом наконечник стрелки зачастую опускают.[/Aside]
Как и для функций, для стрелок можно рисовать диаграммы. Например, вот диаграмма для [Equation](\mathcal{P}(\{a, b, c\}), \subseteq)[/Equation]:

[div style:`{ "width": "60%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsOCxbMSwzLCJcXHtcXH0iXSxbMCwyLCJcXHthXFx9Il0sWzEsMiwiXFx7YlxcfSJdLFsyLDIsIlxce2NcXH0iXSxbMCwxLCJcXHthLGJcXH0iXSxbMSwxLCJcXHthLCBjXFx9Il0sWzIsMSwiXFx7YiwgY1xcfSJdLFsxLDAsIlxce2EsIGIsY1xcfSJdLFswLDFdLFswLDJdLFswLDNdLFsxLDRdLFsxLDVdLFsyLDRdLFsyLDZdLFszLDZdLFszLDVdLFs0LDddLFs1LDddLFs2LDddXQ==&embed"
height:400 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Пусть [Equation]S_\leqslant[/Equation] и [Equation]T_\sqsubseteq[/Equation] — упорядоченные множества.
Функция [Equation]f : S \to T[/Equation] называется монотонной, если

[Equation display:true]
(\forall x, y \in S)\enspace x \leqslant y \implies f(x) \sqsubseteq f(y)
[/Equation]

Отображения, сохраняющие структуру, в алгебре обычно называются гомоморфизмами. В случае множеств,
в определение функции входят множества, соответствующие области и кообласти функции. В случае же упорядоченных
множеств нам бы хотелось, чтобы область и кооблась были также упорядоченными множествами. Поэтому мы
определяем гомоморфизм из [Equation]S_\leqslant[/Equation] в [Equation]T_\sqsubseteq[/Equation] как
тройку [Equation](S_\leqslant, T_\sqsubseteq, f)[/Equation].

Кроме того, для этой тройки определим проекции

[Equation display:true]
\begin{aligned}
dom((S_\leqslant, \_, \_)) &= S_\leqslant \\
cod((\_, T_\sqsubseteq, \_)) &= T_\sqsubseteq \\
set((\_, \_, f)) &= f
\end{aligned}
[/Equation]

Аналогично отношению принадлежности, если [Equation]f : S_\leqslant \to T_\sqsubseteq[/Equation], то
[Equation]f(x)[/Equation] означает [Equation]set(f)(x)[/Equation].

[Aside]
Из того, что [Equation]set(f)[/Equation] — биекция, вовсе не следует, что [Equation]f[/Equation] — изоморфизм.
Например, гомоморфизм из [Equation]Free(\{\varnothing, \{\varnothing\}\})[/Equation] в [Equation](\mathcal{P}(\{\varnothing\}), \subseteq)[/Equation] не является
изоморфизмом, так как обратная функция не является монотонной.
[/Aside]
Гомоморфизм [Equation]f : S_\leqslant \to T_\sqsubseteq[/Equation] называется изоморфизмом, если
существует такой гомоморфизм [Equation]f^{-1} : T_\sqsubseteq \to S_\leqslant[/Equation], что
[Equation]f \mathbin\bm; f^{-1} = \mathrm{id}_{S_\leqslant}[/Equation] и [Equation]f^{-1} \mathbin\bm; f = \mathrm{id}_{T_\sqsubseteq}[/Equation].
Соответствующие упорядоченные множества называются изоморфными (пишется [Equation]S_\leqslant \cong T_\sqsubseteq[/Equation]).

Любое множество можно превратить в упорядоченное с помощью дискретного (свободного) отношения порядка:

[Equation display:true]
Free(S) = (S, (x, y) \mapsto x = y)
[/Equation]

В частности, мы можем определить [Equation]\bm 0[/Equation] и [Equation]\bm 1[/Equation]:

[Equation display:true]
\begin{aligned}
\bm 0 &= Free(\{\}) \\
\bm 1 &= Free(\{\varnothing\})
\end{aligned}
[/Equation]

И как и в случае с обычными множествами, для любого упорядоченного множества [Equation]S[/Equation] существует
единственный гомоморфизм из [Equation]\bm 0[/Equation] в [Equation]S[/Equation], и единственный гомоморфизм из [Equation]S[/Equation] в [Equation]\bm 1[/Equation].

**Предложение:** пусть [Equation]S[/Equation] — множество, [Equation]P[/Equation] — упорядоченное множество,
а [Equation]f : S \to set(P)[/Equation]. Тогда существует единственный гомоморфизм [Equation]u : Free(S) \to P[/Equation],
такой, что следующая диаграмма коммутирует:

[div style:`{ "width": "70%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMCwwLCJTIl0sWzIsMCwic2V0KEZyZWUoUykpIl0sWzIsMiwic2V0KFApIl0sWzEsMiwic2V0KHUpIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMSwiaWRfUyJdLFswLDIsImYiLDJdXQ==&embed"
height:300 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Действительно, [Equation]u = (Free(S), P, f)[/Equation].

Таким образом, [Equation]Free(S)[/Equation] является наиболее общим упорядоченным множеством, порождённым
множеством [Equation]S[/Equation].

Свободные объекты бывают и у других алгебраических структур, но,
как правило, определяются куда менее прямолинейно, хотя и удволетворяют тому же универсальному
свойству, только лишь [Equation]id_S[/Equation] заменяется на некое каноническое вложение [Equation]i : S \to Free(S)[/Equation].

Пусть [Equation]S[/Equation] и [Equation]T[/Equation] — упорядоченные множества. Прямое произведение [Equation]S \times T[/Equation] это
следующее упорядоченное множество:

[Equation display:true]
\begin{aligned}
S \times T = (
&set(S) \times set(T), \\
&((a, x), (b, y)) \mapsto rel(S)(a, b) \mathbin\mathrm{and} rel(T)(x, y))
\end{aligned}
[/Equation]

Как и у свободного упорядоченного множества, у прямого произведения есть универсальное свойство.

**Предложение:** пусть [Equation]S[/Equation] и [Equation]T[/Equation] — упорядоченные множества.
Пусть также даны гомоморфизмы [Equation]f : X \to S[/Equation] и [Equation]g : X \to T[/Equation].
Тогда существует единственный гомоморфизм [Equation]u : X \to S \times T[/Equation], такой, что
следующаяя диаграмма коммутирует:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywwLCJYIl0sWzMsMiwiU1xcdGltZXMgVCJdLFswLDMsIlMiXSxbNiwzLCJUIl0sWzAsMSwidSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMywiZyJdLFswLDIsImYiLDJdXQ==&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Здесь [Equation]\pi_1[/Equation] и [Equation]\pi_2[/Equation] это проекции из [Equation]S \times T[/Equation]:

[Equation display:true]
\begin{aligned}
\pi_1((x, \_)) &= x \\
\pi_2((\_, y)) &= y
\end{aligned}
[/Equation]

В самом деле, единственным таким гомоморфизмом является следующий:

[Equation display:true]
\begin{aligned}
u = (&X, \\
&S \times T, \\
&x \mapsto (f(x), g(x)))
\end{aligned}
[/Equation]

Как и произведение множеств, прямое произведение удволетворяет следующим свойствам:

[Equation display:true]
\begin{aligned}
S \times \bm 0 &\cong \bm 0 \\
S \times \bm 1 &\cong \bm S \\
S \times T &\cong T \times S \\
(S \times T) \times R &\cong S \times (T \times R)
\end{aligned}
[/Equation]

Пусть [Equation]S[/Equation] — упорядоченное множество. Элемент [Equation]a \in S[/Equation] называется минимальным,
если не существует такого [Equation]b \in S[/Equation], что [Equation]a > b[/Equation] ([Equation]a[/Equation] и [Equation]b[/Equation] могут быть несравнимы).
Элемент [Equation]a \in S[/Equation] называется наименьшим, если [Equation](\forall b \in S)\enspace a \leqslant b[/Equation].

Аналогично определяются максимальный и наименьший элементы. Наибольший и наименьший элементы обозначаются,
соответственно, как [Equation]\operatorname{max} S[/Equation] и [Equation]\operatorname{min} S [/Equation].

Кроме того, для [Equation]x, y \in S[/Equation] можно определить операции пересечения и объединения:

[Equation display:true]
\begin{aligned}
x \wedge y &= \operatorname{max}\ \{s \in S \mid s \leqslant x \mathbin\mathrm{and} s \leqslant y\} \\
x \vee y &= \operatorname{min}\ \{s \in S \mid x \leqslant s \mathbin\mathrm{and} y \leqslant s\} \\
\end{aligned}
[/Equation]

В случае, когда [Equation]x[/Equation] и [Equation]y[/Equation] сравнимы, [Equation]x \wedge y = \operatorname{min}\ \{x, y\}[/Equation], а [Equation]x \vee y = \operatorname{max}\ \{x, y\}[/Equation].

[Aside]Слова «единственная» и «коммутирует» в данном контексте могут показаться избыточными, но в случае элементов упорядоченного множества они и в самом деле избыточны.[/Aside]
Если мы выразим выражение для пересечения элементов как диаграмму стрелок, то обнаружим, что пересечение
также обладает универсальным свойством. А именно, пусть [Equation]s \leqslant x[/Equation] и [Equation]s \leqslant y[/Equation].
Тогда существует единственная стрелка [Equation]s \leqslant x \wedge y[/Equation], такая, что следующая
диаграмма коммутирует:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywxLCJ4IFxcd2VkZ2UgeSJdLFszLDMsInMiXSxbMCwwLCJ4Il0sWzYsMCwieSJdLFsxLDAsIiIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDNdLFswLDJdLFsxLDJdLFsxLDNdXQ==&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Обращение всех стрелок даёт универсальное свойство для объединения элементов.

Линейно упорядоченное множество называется вполне упорядоченным, если любое непустое его подмножество
содержит наименьший элемент этого подмножества. Соответствующее отношение порядка называется фундированным.

Вполне упорядоченные множества тесно связаны с рекурсией и математической индукцией. Чтобы это показать,
введём один важный математический принцип.

[Aside]Вообще, это утверждение является теоремой, которая в теории множеств доказывается достаточно
извращённым образом. Мы её доказывать не будем, тем более, что в некоторых аксиоматиках теории множеств
это утверждение является аксиомой (например, в ETCS).[/Aside]
**Принцип итерации:** пусть [Equation]f : A \to A[/Equation]. Тогда, для любого [Equation]a \in A[/Equation] существует
функция [Equation]g : \Bbb N \to A[/Equation], такая, что [Equation]g(0) = a[/Equation] и [Equation]g(n + 1) = f(g(n))[/Equation].

Иначе говоря, [Equation]f^{n}(a)[/Equation] существует и является функцией от [Equation]n[/Equation].

Для элемента [Equation]a[/Equation] можно определить элемент, следующий за ним:

[Equation display:true]succ(a) = \operatorname{min}\ \{s \mid s > a \}[/Equation]

Элемент вполне упорядоченного множества называется предельным, если он не следует ни за каким элементом.

**Предложение:** пусть [Equation]S[/Equation] — линейно упорядоченное множеств, в котором не существует бесконечной
цепи вида [Equation]\dots < a_1 < a_0[/Equation]. Тогда [Equation]S[/Equation] является вполне упорядоченным множеством.

От противного. Пусть [Equation]S[/Equation] не является вполне упорядоченным. Это означает, что
существует непустое множество [Equation]A \subseteq S[/Equation], не имеющее наименьшего элемента.

Введём функцию:

[Equation display:true]
p(x) = \varepsilon(\{a \in A \mid a < x\})
[/Equation]

Эта функция определена на всех элементах множества [Equation]A[/Equation]: в самом деле, если
множество [Equation]\{a \in A \mid a < m\}[/Equation] пусто для какого-то [Equation]m \in A[/Equation],
то [Equation]m[/Equation] является наименьшим элементом множества [Equation]A[/Equation].

Но в таком случае [Equation]p^n(\varepsilon(A))[/Equation] определяет бесконечную нисходящую цепь,
что противоречит тому, что подобной цепи не существует.

Из доказанного следует, что любой элемент вполне упорядоченного множества представим
в виде [Equation]succ^n(l)[/Equation], где [Equation]n \in \Bbb N[/Equation], а [Equation]l[/Equation] — некий
предельный элемент.

(трансфинитная индукция)

(трансфинитная рекурсия)

### Рекурсивные определения

В программировании у нас есть такие волшебные вещи, как рекурсивные типы и функции. В математике же подобные
вещи являются экзотикой. Но многие вещи намного проще и естественне выражать рекурсивно, так что имеет смысл
перенести эти понятия из программирования в математику.

Для начала, нам потребуются типы-суммы. Их аналогом в математике является размеченное объединение:

[Aside]
Чаще его обозначают как [Equation]A \sqcup B[/Equation]. Но мы пишем [Equation]+[/Equation]
чтобы подчеркнуть связь с [Equation]\times[/Equation].
[/Aside]
[Equation display:true]
S_1 + \dots + S_n = \hspace{-0.7em}\bigcup_{i \in \{0, \dots, n\}} \hspace{-0.7em}(\{i\} \times A)
[/Equation]

Размеченными объединениями неудобно пользоваться без имён, так что стоит заимстововать искусство
давать вещам имена из программирования.

Запись [Equation]S = (left: A) + (right: B)[/Equation] означает, что [Equation]S = A + B[/Equation]
и при этом определены следующие функции в [Equation]S[/Equation]:

[Equation display:true]
\begin{aligned}
left(a) &= (0, a) \\
right(b) &= (1, b)
\end{aligned}
[/Equation]

Аналогично, запись [Equation]S = (first: A) \times (second: B)[/Equation] означает,
что [Equation]S = A \times B[/Equation] и при этом определены следующие функции из [Equation]S[/Equation]:

[Equation display:true]
\begin{aligned}
first((x, y)) &= x \\
second((x, y)) &= y
\end{aligned}
[/Equation]

Элемент сооветствующего множества мы будем обозначать или как [Equation](first = a, second = b)[/Equation],
или просто как [Equation](a, b)[/Equation].

Размеченные объединения в том виде как мы их определили не могут быть рекурсивными, так как схема построения
классов не допускает рекурсии. Но мы можем выразить такие рекурсивные множества итеративно.

Например, рассмотрим формальное выражение [Equation]L = (nil: \bm 1) + (cons: A \times L)[/Equation]. Сначала,
мы строим множество, содержащее только нерекурсивные части этого выражения:

[Equation display:true]
L_0 = \{0\} \times \bm 1
[/Equation]

Затем мы определяем функцию, подставляющую данное множество в формальное определение [Equation]L[/Equation]:

[Equation display:true]
\ell(L) = (\{0\} \times \bm 1) \cup (\{1\} \times (A \times L))
[/Equation]

И определяем [Equation]L[/Equation] как:

[Equation display:true]
L = \bigcup_{n \in \Bbb N} L_n \qquad L_n = \ell^{n} (L_0)
[/Equation]

Уровень элемента [Equation]l \in L[/Equation] определим как

[Equation display:true]
lvl(l) = \min\,\{n \in \Bbb N \mid l \in L_n\}
[/Equation]

Мы можем сформулировать принцип математической индукции для рекурсивно определённых множеств:

- Пусть [Equation]\psi(x)[/Equation] верно для всех [Equation]x \in L_0[/Equation]
- Пусть также из того, что [Equation](\forall x \in L_n)\enspace \psi(x)[/Equation] следует [Equation](\forall x \in L_{n + 1})\enspace \psi(x)[/Equation]
- Тогда [Equation]\psi(x)[/Equation] верно для всех [Equation]x \in L[/Equation]

Теперь определим рекурсивные функции из [Equation]L \to S[/Equation]. Рассмотрим следующее определение:

[Equation display:true]
f = \begin{cases}
nil(\_) &\mapsto s_0 \\
cons(a, l) &\mapsto g(a, f(l))
\end{cases}
[/Equation]

Этому определению соответствуют следующие функции:

[Equation display:true]
\begin{aligned}
f_0(nil(\_)) &= s_0 \\
f(\varphi, l) &= \begin{cases}
nil(\_) &\mapsto s_0 \\
cons(a, l) &\mapsto g(a, \varphi(l))
\end{cases}
\end{aligned}
[/Equation]

Теперь рассмотрим графики:

### Моноиды

Наша первая алгебраическая структура это моноид. Моноид это тройка [Equation](M, {\cdot}, e)[/Equation],
где [Equation]M[/Equation] — множество, [Equation](\cdot): M \times M \to M[/Equation], а [Equation]e \in M[/Equation].
При этом должны выполняться следующие аксиомы:

[Equation display:true]
\begin{aligned}
(\forall m \in M)\enspace &e \cdot m = m \cdot e = m \\
(\forall m, n, p \in M)\enspace (&m \cdot n) \cdot p = m \cdot (n \cdot p)
\end{aligned}
[/Equation]

Первая аксиома это аксиома единицы, когда же вторая — ассоциативность.

Примеры моноидов:

- Сложение и умножение чисел
- Конкатенация строк
- Объединение и пересечение множеств
- Умножение матриц n × n
- Композиция функций [Equation]S \to S[/Equation]
- И многое, многое другое

На классе всех моноидов определено забывающее отображение:

[Equation display:true]
Forget((M, {\cdot}, e)) = M
[/Equation]

Мы будем писать [Equation]m \in M^{(\cdot)}[/Equation] имея в виду [Equation]m \in Forget(M^{(\cdot)})[/Equation].

Элемент [Equation]m^{-1} \in M^{(\cdot)}[/Equation] называется обратным к [Equation]m[/Equation] если [Equation]m \cdot m^{-1} = m^{-1} \cdot m = e[/Equation].
Моноид, каждый элемент которого обратим, называется группой.

Аксиомы моноида не просто так похожи на свойства композиции функций: каждому [Equation]m \in M^{(\cdot)}[/Equation]
можно сопоставить соответствующую функцию из [Equation]M[/Equation] в [Equation]M[/Equation]:

[Equation display:true]
f_m(x) = x \cdot m
[/Equation]

Умножению элементов [Equation]m \cdot n[/Equation] соответствует композиция функций [Equation]f_m \mathbin{\bm;} f_n[/Equation].

В случае алгебраических структур, нас интересуют не просто отображения между множествами, а отображения,
сохраняющие стуктуру. Такие отображения называются гомоморфизмами.

Гомоморфизм из моноида [Equation]M^{(\cdot)} = (M, {\cdot}, e_M)[/Equation] в моноид [Equation]N^{*} = (N, {*}, e_N)[/Equation] это
тройка [Equation](M^{(\cdot)}, N^{*}, \tilde f)[/Equation], где [Equation]\tilde f : M \to N[/Equation], для которой верно следующее:

[Equation display:true]
\begin{aligned}
f(e_M) &= e_N \\
f(x \cdot y) &= f(x) * f(y) \qquad (\forall x, y \in M)
\end{aligned}
[/Equation]

Для гомоморфизмов также определено забывающее отображение:

[Equation display:true]
Forget((M^{(\cdot)}, N^{*}, \tilde f)) = \tilde f
[/Equation]

И аналогично отношению принадлежности, мы пишем [Equation]f(m)[/Equation] имея в ввиду [Equation]Forget(f)(m)[/Equation].

Гомоморфизм переносит равенства из одного моноида в другой.
Например, в случае [Equation](\_ \bmod 12) : \Bbb Z^{+} \to \Bbb Z/12[/Equation]:

[Equation display:true]
6 + 13 - 16 = 3 \implies 6 +_{12} 1 +_{12} 8 = 3
[/Equation]

**Предложение:** пусть [Equation]f[/Equation] — биекция, соответствующая гомоморфизму из [Equation](M, {\cdot}, e_M)[/Equation] в [Equation](N, {*}, e_N)[/Equation].
Тогда [Equation]f^{-1}[/Equation] это функция, соответствующая гомоморфизму из [Equation](N, {*}, e_N)[/Equation] в [Equation](M, {\cdot}, e_M)[/Equation].

В самом деле:

[Equation display:true]
\begin{aligned}
f^{-1}(e_N) &= e_M \\
f^{-1}(f(x \cdot y)) &= x \cdot y \\
&= f^{-1}(f(x) * f(y))
\end{aligned}
[/Equation]

Подставив [Equation]x = f^{-1}(\xi)[/Equation] и [Equation]y = f^{-1}(\eta)[/Equation] во второе
уравнение, получаем:

[Equation display:true]
f^{-1}(\xi * \eta) = f^{-1}(\xi) \cdot f^{-1}(\eta)
[/Equation]

Гомоморфизм, функция которого биективна, называется изморфизмом. Моноиды [Equation]M[/Equation] и [Equation]N[/Equation]
называются изоморфными (пишется [Equation]M \cong N[/Equation]), если между ними существует изоморфизм.

Тривиальный моноид это моноид, содержащий только лишь нейтральный элемент:
[Equation display:true]\bm 1 = (\{e\}, {\cdot}, e)[/Equation]

Как и в случае со множествами, каждому моноиду [Equation]M[/Equation] соответствует единственный
гомоморфизм из [Equation]M[/Equation] в [Equation]\bm 1[/Equation]. Однако, гомоморфизм из [Equation]\bm 1[/Equation]
в [Equation]M[/Equation] также единственнен.

Прямое произведение моноидов [Equation]M^{(\cdot)} = (M, {\cdot}, e_M)[/Equation] и [Equation]N^{*} = (N, {*}, e_N)[/Equation] это
моноид [Equation]M^{(\cdot)} \times N^{*}[/Equation], определённый следующим образом:

[Equation display:true]
\begin{aligned}
M^{(\cdot)} \times N^{*} = (
  &M \times N, \\
  &((a, x), (b, y)) \mapsto (a \cdot b, x * y), \\
  &(e_M, e_N)
)
\end{aligned}
[/Equation]

Для прямого произведения [Equation]M\times N[/Equation] определены проекции в [Equation]M[/Equation]
и [Equation]N[/Equation]:

[Equation display:true]
\begin{aligned}
\pi_1((a, x)) = a \\
\pi_2((a, x)) = x
\end{aligned}
[/Equation]

Для любых моноидов [Equation]M[/Equation], [Equation]N[/Equation] и [Equation]P[/Equation] верно:

[Equation display:true]
\begin{aligned}
M \times \bm 1 &\cong M \\
M \times N &\cong N \times M \\
(M \times N) \times P &\cong M \times (N \times P)
\end{aligned}
[/Equation]

Пусть [Equation]M[/Equation], [Equation]N[/Equation] и [Equation]X[/Equation] — моноиды. Пусть также даны
гомоморфизмы [Equation]f: X \to M[/Equation] и [Equation]f: X \to N[/Equation]. Тогда существует
единственный гомоморфизм [Equation]u : X \to M \times N[/Equation], такой, что следующая диаграмма
коммутирует:

[div style:`{ "width": "95%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsNCxbMywwLCJYIl0sWzMsMiwiTVxcdGltZXMgTiJdLFswLDMsIk0iXSxbNiwzLCJOIl0sWzAsMSwidSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFsxLDIsIlxccGlfMSJdLFsxLDMsIlxccGlfMiIsMl0sWzAsMywiZyJdLFswLDIsImYiLDJdXQ==&embed"
height:350 width:600
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

В самом деле, есть лишь один способ построить такой гомоморфизм:
[Equation display:true]
u(x) = (f(x), g(x))
[/Equation]

[Aside]Сами деревья конечны, в отличие от грамматики ([Equation]S[/Equation] может быть бесконечным и даже несчётным).[/Aside]
Пусть [Equation]S[/Equation] — какое-то множество. Определим множество синтаксических деревьев [Equation]E[/Equation]
следующим образом:

[Equation display:true]
\begin{aligned}
E \Coloneqq\ &\mathsf{e} \\
\mid\enspace\, &s \qquad (s \in S) \\
\mid\enspace\, &E \cdot E
\end{aligned}
[/Equation]

Также определим отношение эквивалентности, соответствующее аксиомам моноида:

[Equation display:true]
\begin{aligned}
\mathsf e \cdot x &\sim x \\
x \cdot \mathsf e &\sim x \\
(x \cdot y) \cdot z &\sim x \cdot (y \cdot z)
\end{aligned}
[/Equation]

Синтаксические деревья вместе с отношением эквивалентности позволяют определить моноид:

[Equation display:true]
\begin{aligned}
Free(S) = (
  &E/{\sim},\\
  &([a]_\sim, [b]_\sim) \mapsto [a \cdot b]_\sim,\\
  &\mathsf e
)
\end{aligned}
[/Equation]

Моноид, изоморфный [Equation]Free(S)[/Equation], называется свободным.

Примеры свободных моноидов:

- (`List[T]`, `concat`, `[]`)
- (`String`, `concat`, `""`)
- [Equation]\Bbb N^{+}[/Equation]

Свободный моноид это наиболее общий моноид, порождённый данным множеством. Формально, это можно
выразить следующим универсальным свойством: пусть [Equation]S[/Equation] — множество, [Equation]M[/Equation] — моноид,
а [Equation]f: S \to Forget(M)[/Equation]. Тогда существует единственный гомоморфизм [Equation]u : Free(S) \to M[/Equation],
такой, что следующая диаграмма коммутирует:

[div style:`{ "width": "70%", "marginLeft": "auto", "marginRight": "auto" }`]
[iframe
src:"https://q.uiver.app/?q=WzAsMyxbMCwwLCJTIl0sWzIsMCwiRm9yZ2V0KEZyZWUoUykpIl0sWzIsMiwiRm9yZ2V0KE0pIl0sWzEsMiwiRm9yZ2V0KHUpIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzAsMSwiaSJdLFswLDIsImYiLDJdXQ==&embed"
height:300 width:400
style:`{ "borderRadius": "8px", "border": "none" }`
][/iframe]
[/div]

Здесь [Equation]i[/Equation] это естественное вложение [Equation]S[/Equation] в [Equation]Forget(Free(S))[/Equation]:

[Equation display:true]
i(s) = s
[/Equation]

Мы можем определить гомоморфизм [Equation]u[/Equation] рекурсивно:

[Equation display:true]
u(m) = \begin{cases}
f(s), &s \in S, \\
e_M, &m = \mathsf e,\\
u(x) * u(y), &m = x \cdot y
\end{cases}
[/Equation]

Из этого определения следует, что [Equation]u[/Equation] в самом деле единственнен: первое равенство следует из
коммутативности диаграммы, когда же остальные — из определения гомоморфизма.

## Категории
